<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hi,ghostsf</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ghostsf.com/"/>
  <updated>2020-04-01T09:51:38.587Z</updated>
  <id>https://ghostsf.com/</id>
  
  <author>
    <name>ghostsf</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>海康威视 hikvision SDK 二次开发</title>
    <link href="https://ghostsf.com/hikvision/"/>
    <id>https://ghostsf.com/hikvision/</id>
    <published>2020-03-27T11:50:23.000Z</published>
    <updated>2020-04-01T09:51:38.587Z</updated>
    
    <content type="html"><![CDATA[<h1 id="桌面软件管控端开发"><a href="#桌面软件管控端开发" class="headerlink" title="桌面软件管控端开发"></a>桌面软件管控端开发</h1><p>二次开发 sdk 下载，<a href="https://www.hikvision.com/cn/download_61.html" target="_blank" rel="noopener">https://www.hikvision.com/cn/download_61.html</a></p><p>该设备网络 SDK 是基于设备私有网络通信协议开发的，为后端设备（嵌入式网络硬盘录像机、视频服务器）、前端设备（网络摄像机、网络球机、IP 模块）等产品服务的配套模块，用于远程访问和控制设备软件的二次开发。</p><p>sdk 压缩包包含的内容还是比较多的，有各种 demo，目前有 python（psdatacall_demo）、Qt（QtDemo）、Java（LinuxJavaDemo）和 C++（consoleDemo），以及详细的开发文档。<br>以 <code>设备网络 SDK_V6.1.4.7(for Linux64)</code> 为例：<br><img src="https://cdn.ghostsf.com/uPic/WX20200331-205742@2x.png" alt="设备网络 SDK_V6.1.4.7(for Linux64)"></p><p>按照说明文档，先将动态库设置好。不同平台都有对应的说明。相对而言，windows 系统比较方便（用得也相对较多，相对而言坑也比较少，推荐），mac os 就有点麻烦，如果用 linux 的 sdk 的话，需要将所有 <code>.so</code> 的库文件都改为 <code>.dylib</code>，具体可以自行摸索，这里就不赘述了。</p><p>跑一个 Java 的 demo，demo 界面大概如此：</p><p><img src="https://cdn.ghostsf.com/uPic/EU6uMq.png" alt="Java demo"></p><p><img src="https://cdn.ghostsf.com/uPic/XpdccT.png" alt="java demo2"></p><h1 id="web3-0-网页控件二次开发"><a href="#web3-0-网页控件二次开发" class="headerlink" title="web3.0 网页控件二次开发"></a>web3.0 网页控件二次开发</h1><p>不需要使用桌面端软件的，可以使用海康威视的 web 网页控件集成。</p><p>海康威视网页控件 sdk 开发包一般需要提交信息发邮件申请。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">请将以下信息提供完整，发送到 sdk@hikvision.com 邮箱，会有 SDK 工程师回复您的问题</span><br><span class="line">a、您的具体开发需求。</span><br><span class="line">b、开发设备型号及版本</span><br><span class="line">c、开发环境及开发语言</span><br><span class="line">d、贵公司名称，联系人，联系电话，邮箱地址</span><br></pre></td></tr></table></figure><p>ghostsf 这里给大家整理了一份：<a href="https://github.com/ghostsf/hikvision-web" target="_blank" rel="noopener">https://github.com/ghostsf/hikvision-web</a></p><p>开发包中有 demo，有文档，有中英文版，需要 ActiveX 控件，所以对浏览器有限制，需要 有 IE 内核的浏览器。</p><p>使用网页控件之前电脑上需要先安装 <code>WebComponents.exe</code> 。</p><p>网页控件相关功能方法都在 <code>webVideoCtrl.js</code> 里，可以结合 demo 对应查看。</p><p>web 开发包里面也已经提供了 API 的说明文档 ，我们也可以对照 API ，调用 <code>webVideoCtrl.js</code> 里面的方法就可以实现我们需要的功能。</p><p>这里先借用下别人的图，看下 web demo：</p><p><img src="https://cdn.ghostsf.com/uPic/H4ALkz.png" alt="web demo"></p><p>需要点击允许 ActiveX 控件。</p><p><img src="https://cdn.ghostsf.com/uPic/AWXmwh.png" alt="web demo2"></p><h1 id="海康移动客户端二次开发"><a href="#海康移动客户端二次开发" class="headerlink" title="海康移动客户端二次开发"></a>海康移动客户端二次开发</h1><p>移动客户端二次开发 sdk，也需要提交信息发送邮件获取。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">不管是安卓还是 IOS 的开发，请将以下信息提供完整，发送到 sdk@hikvision.com 邮箱，会有 SDK 工程师回复您的问题。</span><br><span class="line">a、公司名称：</span><br><span class="line">b、开发的设备型号和版本号（务必提供没有型号原则上开发包不予提供）：</span><br><span class="line">c、需要实现的功能：</span><br><span class="line">d、开发平台 android&#x2F;ios：</span><br><span class="line">e、网络环境（是否有固定 IP）：</span><br></pre></td></tr></table></figure><p>ghostsf 这里给大家 整理了一份：<a href="https://github.com/ghostsf/hikvision-android" target="_blank" rel="noopener">https://github.com/ghostsf/hikvision-android</a></p><p>具体开发，这里就不赘述了。</p><p>可以参考这些文章：</p><p><a href="https://blog.csdn.net/wljs17/article/details/92979250" target="_blank" rel="noopener">基于 Android 的海康威视的二次开发</a></p><p><a href="https://blog.csdn.net/weixin_40042248/article/details/81664198" target="_blank" rel="noopener">基于海康威视网络摄像机的 Android 二次开发</a></p><h1 id="海康威视手机、电脑常用软件下载"><a href="#海康威视手机、电脑常用软件下载" class="headerlink" title="海康威视手机、电脑常用软件下载"></a>海康威视手机、电脑常用软件下载</h1><p>查看【海康威视客户服务】微信公众号发布的这篇图文即可。</p><p><a href="https://mp.weixin.qq.com/s/hVUM5WNEbGERW7DbKeRFzQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/hVUM5WNEbGERW7DbKeRFzQ</a></p><h1 id="其他说明"><a href="#其他说明" class="headerlink" title="其他说明"></a>其他说明</h1><p>如果不知道摄像头的 ip， 用户名，密码，端口号是多少，可以安装 SADP 软件。SADP 可以看到同一个局域网下面每个摄像头的详情。如果忘记密码了，可以在 SADP 里选择设备进行密码恢复。</p><p>更多贴心服务，知识库等，可以微信关注【海康威视客户服务】微信公众号，进行详细了解。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;桌面软件管控端开发&quot;&gt;&lt;a href=&quot;#桌面软件管控端开发&quot; class=&quot;headerlink&quot; title=&quot;桌面软件管控端开发&quot;&gt;&lt;/a&gt;桌面软件管控端开发&lt;/h1&gt;&lt;p&gt;二次开发 sdk 下载，&lt;a href=&quot;https://www.hikvision
      
    
    </summary>
    
    
      <category term="技术栈" scheme="https://ghostsf.com/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="海康威视" scheme="https://ghostsf.com/tags/%E6%B5%B7%E5%BA%B7%E5%A8%81%E8%A7%86/"/>
    
      <category term="hikvision" scheme="https://ghostsf.com/tags/hikvision/"/>
    
  </entry>
  
  <entry>
    <title>git各案例命令记录</title>
    <link href="https://ghostsf.com/git-collect/"/>
    <id>https://ghostsf.com/git-collect/</id>
    <published>2020-03-25T10:20:18.000Z</published>
    <updated>2020-04-01T09:51:38.587Z</updated>
    
    <content type="html"><![CDATA[<h2 id="更改本地和远程分支的名称"><a href="#更改本地和远程分支的名称" class="headerlink" title="更改本地和远程分支的名称"></a>更改本地和远程分支的名称</h2><p>git branch -m old_branch new_branch # Rename branch locally</p><p>git push origin :old_branch # Delete the old branch</p><p>git push –set-upstream origin new_branch # Push the new branch, set local branch to track the new remote</p><h2 id="打增量更新包"><a href="#打增量更新包" class="headerlink" title="打增量更新包"></a>打增量更新包</h2><p>git diff {old commit version} {new commit version} –name-only | xargs tar -czvf update.tar.gz</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;更改本地和远程分支的名称&quot;&gt;&lt;a href=&quot;#更改本地和远程分支的名称&quot; class=&quot;headerlink&quot; title=&quot;更改本地和远程分支的名称&quot;&gt;&lt;/a&gt;更改本地和远程分支的名称&lt;/h2&gt;&lt;p&gt;git branch -m old_branch new_b
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>重识B3log</title>
    <link href="https://ghostsf.com/B3log/"/>
    <id>https://ghostsf.com/B3log/</id>
    <published>2020-03-11T10:38:40.000Z</published>
    <updated>2020-04-01T09:51:38.583Z</updated>
    
    <content type="html"><![CDATA[<p>B3log 最初建立的时候我就加入了<br>依稀记得 我注册了黑客派的<br>可是没搜到账号记录<br>那就当重新认识一下吧<br>&nbsp;<br>起初 觉得 B3log 的 logo 好老土（现在也有点）<br>第一眼看到黑客派 感觉很空乏 （可能是用户还很少 没有多少数据）<br>然后不自觉地来 轻轻地 我又离开了</p><a id="more"></a><p>&nbsp;<br>尔后 看到 88250 开启了一个书单计划（纯粹记忆碎片可能有误）<br>忽然觉得挺有意味<br>还做了一个工具类的小程序<br>&nbsp;<br>尔后 看到 88250 发表了一篇《为什么又要造一个叫 Latke 的轮子》<br>忽然觉得挺有想法<br>麻雀虽小 也有明天<br>&nbsp;<br>尔后看到 B3log 被各种流量攻击 恶意点击<br>还有大 v 的抨击<br>固执邪恶的灵魂永远是存在的<br>&nbsp;<br>后来 关注得少了<br>其实是时间被占用得多了<br>只知道 D 和 V 是一对可爱的、可敬的<br>&nbsp;<br>加油 江湖再见<br>又是春天</p><p>&nbsp;<br>作者：ghostsf<br>链接：<a href="https://hacpai.com/article/1583754874086" target="_blank" rel="noopener">https://hacpai.com/article/1583754874086</a><br>来源：黑客派<br>协议：CC BY-SA 4.0 <a href="https://creativecommons.org/licenses/by-sa/4.0/" target="_blank" rel="noopener">https://creativecommons.org/licenses/by-sa/4.0/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;B3log 最初建立的时候我就加入了&lt;br&gt;依稀记得 我注册了黑客派的&lt;br&gt;可是没搜到账号记录&lt;br&gt;那就当重新认识一下吧&lt;br&gt;&amp;nbsp;&lt;br&gt;起初 觉得 B3log 的 logo 好老土（现在也有点）&lt;br&gt;第一眼看到黑客派 感觉很空乏 （可能是用户还很少 没有多少数据）&lt;br&gt;然后不自觉地来 轻轻地 我又离开了&lt;/p&gt;
    
    </summary>
    
    
      <category term="事件簿" scheme="https://ghostsf.com/categories/%E4%BA%8B%E4%BB%B6%E7%B0%BF/"/>
    
      <category term="闲言语" scheme="https://ghostsf.com/categories/%E4%BA%8B%E4%BB%B6%E7%B0%BF/%E9%97%B2%E8%A8%80%E8%AF%AD/"/>
    
    
      <category term="B3log" scheme="https://ghostsf.com/tags/B3log/"/>
    
      <category term="88250" scheme="https://ghostsf.com/tags/88250/"/>
    
  </entry>
  
  <entry>
    <title>如何学习新技术？</title>
    <link href="https://ghostsf.com/how2learn/"/>
    <id>https://ghostsf.com/how2learn/</id>
    <published>2020-03-06T16:37:08.000Z</published>
    <updated>2020-04-01T09:51:38.587Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/post/how2learn.png" alt="如何学习新技术"></p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/post/how2learn.png&quot; alt=&quot;如何学习新技术&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="分享境" scheme="https://ghostsf.com/categories/%E5%88%86%E4%BA%AB%E5%A2%83/"/>
    
      <category term="技术栈" scheme="https://ghostsf.com/categories/%E5%88%86%E4%BA%AB%E5%A2%83/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="学习" scheme="https://ghostsf.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>简单且高度可扩展的分布式文件系统SeaweedFS</title>
    <link href="https://ghostsf.com/seaweedfs/"/>
    <id>https://ghostsf.com/seaweedfs/</id>
    <published>2020-03-06T16:08:21.000Z</published>
    <updated>2020-04-01T09:51:38.587Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-概述"><a href="#0x00-概述" class="headerlink" title="0x00 概述"></a>0x00 概述</h1><p><img src="https://raw.githubusercontent.com/chrislusf/seaweedfs/master/note/seaweedfs.png" alt="SeaweedFS Logo"></p><p>Github: <a href="https://github.com/chrislusf/seaweedfs" target="_blank" rel="noopener">https://github.com/chrislusf/seaweedfs</a></p><blockquote><p>SeaweedFS is a simple and highly scalable distributed file system, to store and serve billions of files fast! SeaweedFS implements an object store with O(1) disk seek, transparent cloud integration, and an optional Filer with POSIX interface, supporting S3 API, Rack-Aware Erasure Coding for warm storage, FUSE mount, Hadoop compatible, WebDAV.</p></blockquote><p>SeaweedFS是一个简单且高度可扩展的分布式文件系统，可以快速存储和提供数十亿个文件！SeaweedFS通过 O(1) 磁盘搜索，透明云集成以及带有POSIX接口的可选Filer，实现了对象存储，支持S3 API，用于热存储的机架感知擦除编码，FUSE安装，Hadoop兼容，WebDAV。</p><a id="more"></a><h1 id="0x01-基础概念"><a href="#0x01-基础概念" class="headerlink" title="0x01 基础概念"></a>0x01 基础概念</h1><p>随着业务量增长，一个系统需要存储上百万文件的情况越来越多，尤其是互联网网站。在这种情况下依然使用传统磁盘/共享存储的方式进行支持会有以下问题：</p><ul><li><p>文件的备份、恢复困难，大量文件的copy 耗时耗力</p></li><li><p>文件数量暴增占满操作系统文件系统inode，导致磁盘空间虽然没有用完但是因为inode用尽无法使用</p></li><li><p>文件读取效率太低，无法应对高并发读取要求<br>针对以上问题，facebook 提出了自己的方案 <a href="http://www.usenix.org/event/osdi10/tech/full_papers/Beaver.pdf" target="_blank" rel="noopener">Facebook’s Haystack design paper</a> 。 之后各种实现出现，如tfs、MogileFS、GlusterFS等，其中Seaweedfs是一个比较优秀的实现。具有效率高、结构简单、代码清晰等优点。</p></li></ul><p>在逻辑上Seaweedfs的几个概念：</p><table><thead><tr><th>概念</th><th>解释</th></tr></thead><tbody><tr><td>Node</td><td>系统抽象的节点，抽象为DataCenter、Rack、DataNode</td></tr><tr><td>DataCenter</td><td>数据中心，对应现实中的不同机房</td></tr><tr><td>Rack</td><td>机架，对应现实中的机柜</td></tr><tr><td>Datanode</td><td>存储节点，用于管理、存储逻辑卷，其实就是Volume server（卷服务器），而Volume server下是有很多个逻辑卷的</td></tr><tr><td>Volume</td><td>逻辑卷，存储的逻辑结构，逻辑卷下存储Needle</td></tr><tr><td>Needle</td><td>逻辑卷中的Object，对应存储的文件（每个文件有一个唯一needleID）</td></tr><tr><td>Collection</td><td>文件集，可以分布在多个逻辑卷上</td></tr></tbody></table><p><strong>结构说明</strong>：<br><img src="/images/post/seaweed1.png" alt="结构说明"></p><h1 id="0x02-组成部分"><a href="#0x02-组成部分" class="headerlink" title="0x02 组成部分"></a>0x02 组成部分</h1><ol><li><p>基础部分：Master server + Volume server</p></li><li><p>扩展部分：Filer server + Cronjob server (Replication-job) + S3 server</p><blockquote><p>值得注意的一点：外部与 Master Server、Volume Server 和 Filer 进行通信的方式是 HTTP API。API的用法官网有<a href="https://github.com/chrislusf/seaweedfs/wiki/Master-Server-API" target="_blank" rel="noopener">详细说明</a>。</p></blockquote></li></ol><p><strong>部署结构</strong>：<br><img src="/images/post/seaweed2.png" alt="部署说明"></p><h1 id="0x03-快速上手"><a href="#0x03-快速上手" class="headerlink" title="0x03 快速上手"></a>0x03 快速上手</h1><p>从 <a href="https://github.com/chrislusf/seaweedfs/releases" target="_blank" rel="noopener">https://github.com/chrislusf/seaweedfs/releases</a> 下载最新版本</p><p>解压缩下载的文件，只会找到一个可执行文件，在大多数系统上是“ weed”，在Windows上是“ weed.exe”。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./weed -h # to check available options</span><br></pre></td></tr></table></figure><h2 id="配置运行Weed-Master-server"><a href="#配置运行Weed-Master-server" class="headerlink" title="配置运行Weed Master server"></a>配置运行Weed Master server</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./weed master -h # to check available options</span><br></pre></td></tr></table></figure><p>如果不需要复制，就足够了。<code>mdir</code>选项用于配置保存生成的序列文件ID的文件夹。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./weed master -mdir="."</span><br><span class="line">./weed master -mdir="." -ip=xxx.xxx.xxx.xxx # usually set the ip instead the default "localhost"</span><br></pre></td></tr></table></figure><h2 id="配置运行Weed-Volume-Server"><a href="#配置运行Weed-Volume-Server" class="headerlink" title="配置运行Weed Volume Server"></a>配置运行Weed Volume Server</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./weed volume -h # to check available options</span><br></pre></td></tr></table></figure><p>通常，卷服务器分布在不同的服务器上。它们可以具有不同的磁盘空间，甚至可以具有不同的操作系统。</p><p>通常，你需要指定可用磁盘空间，Weed Master地址和存储文件夹。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./weed volume -max=100 -mserver="localhost:9333" -dir="./data"</span><br></pre></td></tr></table></figure><p><strong>PS</strong>：设置一台Weed Master server和一台Weed Volume Server，可以用weed server简写：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./weed server -dir="./data"</span><br><span class="line"><span class="meta">#</span><span class="bash"> same, just specifying the default values</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> use <span class="string">"weed server -h"</span> to find out more</span></span><br><span class="line">./weed server -master.port=9333 -volume.port=8080 -dir="./data"</span><br></pre></td></tr></table></figure><h2 id="测试SeaweedFS"><a href="#测试SeaweedFS" class="headerlink" title="测试SeaweedFS"></a>测试SeaweedFS</h2><p>随着主服务器和卷服务器的启动，现在呢？让我们将大量文件注入系统！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./weed upload -dir="/some/big/folder"</span><br></pre></td></tr></table></figure><p>此命令将以递归方式上载所有文件。或者，您可以指定要包括的文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./weed upload -dir="/some/big/folder" -include=*.txt</span><br></pre></td></tr></table></figure><p>然后，您只需检查“ du -m -s / some / big / folder”即可查看操作系统的实际磁盘使用情况，并将其与“ / data”下的文件大小进行比较。通常，如果您要上传大量文本文件，则消耗的磁盘大小会小得多，因为文本文件会自动压缩。</p><h1 id="0x04-在docker中使用"><a href="#0x04-在docker中使用" class="headerlink" title="0x04 在docker中使用"></a>0x04 在docker中使用</h1><p>与docker一起使用很容易，因为它在本地运行，您可以像上面那样传递所有args。但是您不必担心“ -ip”。入口点脚本将对其进行处理。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 9333:9333 --name master chrislusf/seaweedfs master -ip=master</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 8080:8080 -p 18080:18080 --name volume --link master chrislusf/seaweedfs volume -max=5 -mserver="master:9333" -port=8080</span><br></pre></td></tr></table></figure><h2 id="使用compose"><a href="#使用compose" class="headerlink" title="使用compose"></a>使用compose</h2><p>但是使用Compose最简单。要启动，只需运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose -f docker/seaweedfs-compose.yml -p seaweedfs up</span><br></pre></td></tr></table></figure><p>您可以使用映像“ chrislusf / seaweedfs”或在根目录中使用dockerfile构建自己的映像。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name weed chrislusf/seaweedfs server</span><br></pre></td></tr></table></figure><h2 id="从dockerfile构建image"><a href="#从dockerfile构建image" class="headerlink" title="从dockerfile构建image"></a>从dockerfile构建image</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/chrislusf/seaweedfs.git</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build --no-cache -t 'chrislusf/seaweedfs' .</span><br></pre></td></tr></table></figure><h2 id="构建docker-image"><a href="#构建docker-image" class="headerlink" title="构建docker image"></a>构建docker image</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mv Dockerfile Dockerfile.minimal</span><br><span class="line">mv Dockerfile.go_build Dockerfile</span><br><span class="line">docker build --no-cache -t 'chrislusf/seaweedfs' .</span><br></pre></td></tr></table></figure><h2 id="生产使用"><a href="#生产使用" class="headerlink" title="生产使用"></a>生产使用</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> start our weed server daemonized</span></span><br><span class="line">docker run --name weed -d -p 9333:9333 -p 8080:8080 -p 18080:8080 \</span><br><span class="line">  -v /opt/weedfs/data:/data chrislusf/seaweedfs server -dir="/data" \ </span><br><span class="line">  -publicIp="$(curl -s cydev.ru/ip)"</span><br></pre></td></tr></table></figure><p>现在，SeaweedFS服务器将是持久性的，并且可以通过主机上的localhost：9333，：8080和：18080进行访问。不要忘记为指定正确的“ -publicIp”。</p><h1 id="0x05-组成部分介绍"><a href="#0x05-组成部分介绍" class="headerlink" title="0x05 组成部分介绍"></a>0x05 组成部分介绍</h1><h2 id="Master-Server"><a href="#Master-Server" class="headerlink" title="Master Server"></a>Master Server</h2><blockquote><p>Master是不存储数据的，只做集群协调，类似于Zookeeper的作用。</p></blockquote><p>Master Server API 详见 <a href="https://github.com/chrislusf/seaweedfs/wiki/Master-Server-API" target="_blank" rel="noopener">https://github.com/chrislusf/seaweedfs/wiki/Master-Server-API</a></p><p><strong>Tips</strong>：可以使用＆pretty = y附加到任何HTTP API，以查看格式化的json输出。</p><h3 id="分配一个fileId，用于接下来的存储文件"><a href="#分配一个fileId，用于接下来的存储文件" class="headerlink" title="分配一个fileId，用于接下来的存储文件"></a>分配一个fileId，用于接下来的存储文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Basic Usage:</span></span><br><span class="line">curl http://localhost:9333/dir/assign</span><br><span class="line">&#123;"count":1,"fid":"3,01637037d6","url":"127.0.0.1:8080",</span><br><span class="line"> "publicUrl":"localhost:8080"&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> To assign with a specific replication <span class="built_in">type</span>:</span></span><br><span class="line">curl "http://localhost:9333/dir/assign?replication=001"</span><br><span class="line"><span class="meta">#</span><span class="bash"> To specify how many file ids to reserve</span></span><br><span class="line">curl "http://localhost:9333/dir/assign?count=5"</span><br><span class="line"><span class="meta">#</span><span class="bash"> To assign a specific data center</span></span><br><span class="line">curl "http://localhost:9333/dir/assign?dataCenter=dc1"</span><br></pre></td></tr></table></figure><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">curl "http://localhost:9333/dir/lookup?volumeId=3&amp;pretty=y"</span><br><span class="line">&#123;</span><br><span class="line">  "locations": [</span><br><span class="line">    &#123;</span><br><span class="line">      "publicUrl": "localhost:8080",</span><br><span class="line">      "url": "localhost:8080"</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> Other usages:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> You can actually use the file id to lookup, <span class="keyword">if</span> you are lazy to parse the file id.</span></span><br><span class="line">curl "http://localhost:9333/dir/lookup?volumeId=3,01637037d6"</span><br><span class="line"><span class="meta">#</span><span class="bash"> If you know the collection, specify it since it will be a little faster</span></span><br><span class="line">curl "http://localhost:9333/dir/lookup?volumeId=3&amp;collection=turbo"</span><br></pre></td></tr></table></figure><h3 id="强制垃圾收集"><a href="#强制垃圾收集" class="headerlink" title="强制垃圾收集"></a>强制垃圾收集</h3><p>如果您的系统有许多删除操作，则不会同步回收已删除文件的磁盘空间。有一个后台作业可检查卷磁盘使用情况。如果空白空间大于阈值（默认值为0.3），真空作业将使该卷成为只读卷，仅使用现有文件创建一个新卷，然后打开新卷。如果嫌麻烦或正在做一些测试，请用这种方法清理未使用的空间。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl "http://localhost:9333/vol/vacuum"</span><br><span class="line">curl "http://localhost:9333/vol/vacuum?garbageThreshold=0.4"</span><br></pre></td></tr></table></figure><p>garbageThreshold = 0.4是可选的，并且不会更改默认阈值。您可以使用不同的默认垃圾阈值启动卷主机。此操作并非易事。它将尝试制作.dat和.idx文件的副本，跳过已删除的文件，并切换到新文件，删除旧文件。</p><h3 id="预分配卷"><a href="#预分配卷" class="headerlink" title="预分配卷"></a>预分配卷</h3><p>一个卷服务一次写入。如果需要增加并发性，则可以预分配大量卷。这是例子。也可以组合所有不同的选项。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> specify a specific replication</span></span><br><span class="line">curl "http://localhost:9333/vol/grow?replication=000&amp;count=4"</span><br><span class="line">&#123;"count":4&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> specify a collection</span></span><br><span class="line">curl "http://localhost:9333/vol/grow?collection=turbo&amp;count=4"</span><br><span class="line"><span class="meta">#</span><span class="bash"> specify data center</span></span><br><span class="line">curl "http://localhost:9333/vol/grow?dataCenter=dc1&amp;count=4"</span><br><span class="line"><span class="meta">#</span><span class="bash"> specify ttl</span></span><br><span class="line">curl "http://localhost:9333/vol/grow?ttl=5d&amp;count=4"</span><br></pre></td></tr></table></figure><p>这将生成4个空卷。</p><h3 id="删除文件集"><a href="#删除文件集" class="headerlink" title="删除文件集"></a>删除文件集</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> delete a collection</span></span><br><span class="line">curl "http://localhost:9333/col/delete?collection=benchmark&amp;pretty=y"</span><br></pre></td></tr></table></figure><h3 id="检查系统状态"><a href="#检查系统状态" class="headerlink" title="检查系统状态"></a>检查系统状态</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl "http://10.0.2.15:9333/cluster/status?pretty=y"</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl "http://localhost:9333/dir/status?pretty=y"</span><br></pre></td></tr></table></figure><h2 id="Volume-Server"><a href="#Volume-Server" class="headerlink" title="Volume Server"></a>Volume Server</h2><blockquote><p>这个就是所谓的“Data Node”数据节点，用于挂载磁盘存储文件。Volume Server与Master Server通信，受Master控制。可以动态的增加和减少VolumeServer，这一点比另一个云存储MinIO要强得多。</p></blockquote><p>Volume Server API 可详见 <a href="https://github.com/chrislusf/seaweedfs/wiki/Volume-Server-API" target="_blank" rel="noopener">https://github.com/chrislusf/seaweedfs/wiki/Volume-Server-API</a></p><p><strong>Tips</strong>：可以使用＆pretty = y附加到任何HTTP API，以查看格式化的json输出。</p><h3 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -F file=@/home/ghostsf/myphoto.jpg http://127.0.0.1:8080/3,01637037d6</span><br><span class="line">&#123;"size": 43234&#125;</span><br></pre></td></tr></table></figure><p>返回的大小是存储在SeaweedFS上的大小，有时文件会根据mime类型自动压缩。</p><h3 id="直接上传文件"><a href="#直接上传文件" class="headerlink" title="直接上传文件"></a>直接上传文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -F file=@/home/ghostsf/myphoto.jpg http://localhost:9333/submit</span><br><span class="line">&#123;"fid":"3,01fbe0dc6f1f38","fileName":"myphoto.jpg","fileUrl":"localhost:8080/3,01fbe0dc6f1f38","size":68231&#125;</span><br></pre></td></tr></table></figure><p>这个API只是为了方便。主服务器将获得一个文件id并将文件存储到正确的卷服务器。这是一个很方便的API，在分配文件id时不支持不同的参数。</p><h3 id="访问文件"><a href="#访问文件" class="headerlink" title="访问文件"></a>访问文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://127.0.0.1:8080/3,01637037d6</span><br></pre></td></tr></table></figure><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X DELETE http://127.0.0.1:8080/3,01637037d6</span><br></pre></td></tr></table></figure><h3 id="查看分块大文件的清单文件内容"><a href="#查看分块大文件的清单文件内容" class="headerlink" title="查看分块大文件的清单文件内容"></a>查看分块大文件的清单文件内容</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://127.0.0.1:8080/3,01637037d6?cm=false</span><br></pre></td></tr></table></figure><h3 id="检查卷服务器状态"><a href="#检查卷服务器状态" class="headerlink" title="检查卷服务器状态"></a>检查卷服务器状态</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl "http://localhost:8080/status?pretty=y"</span><br></pre></td></tr></table></figure><h2 id="Filer-Server"><a href="#Filer-Server" class="headerlink" title="Filer Server"></a>Filer Server</h2><p>文件管理器（Filer）可以用来 浏览文件和目录，以及add/delete files, and even browse the sub directories and files，还有检索、重命名等。</p><h3 id="配置启动"><a href="#配置启动" class="headerlink" title="配置启动"></a>配置启动</h3><p>将filer.toml文件添加到当前目录，或$ HOME / .seaweedfs / 或 / etc / seaweedfs /filer.toml</p><p>可以通过以下方式生成</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">weed scaffold -config=filer -output="."</span><br></pre></td></tr></table></figure><p>查看的方式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">weed scaffold -config=filer</span><br></pre></td></tr></table></figure><p>filer.toml文件内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[leveldb]</span><br><span class="line">enabled = true</span><br><span class="line">dir = "."# directory to store level db files</span><br></pre></td></tr></table></figure><p>两种方式启动：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> assuming you already started weed master and weed volume</span></span><br><span class="line">weed filer</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Or assuming you have nothing started yet,</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> this <span class="built_in">command</span> starts master server, volume server, and filer <span class="keyword">in</span> one shot. </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> It<span class="string">'s strictly the same as starting them separately.</span></span></span><br><span class="line">weed server -filer=true</span><br></pre></td></tr></table></figure><h3 id="管理文件"><a href="#管理文件" class="headerlink" title="管理文件"></a>管理文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Basic Usage:</span></span><br><span class="line">//create or overwrite the file, the directories /path/to will be automatically created</span><br><span class="line">POST /path/to/file</span><br><span class="line">//get the file content</span><br><span class="line">GET /path/to/file</span><br><span class="line">//create or overwrite the file, the filename in the multipart request will be used</span><br><span class="line">POST /path/to/</span><br><span class="line">//return a json format subdirectory and files listing</span><br><span class="line">GET /path/to/</span><br><span class="line">        Accept: application/json</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> options <span class="keyword">for</span> POST a file:</span></span><br><span class="line">// set file TTL for Cassandra or Redis filer store.</span><br><span class="line">POST /path/to/file?ttl=1d</span><br><span class="line">// set file mode when creating or overwriting a file</span><br><span class="line">POST /path/to/file?mode=0755</span><br></pre></td></tr></table></figure><h3 id="列出目录下的文件"><a href="#列出目录下的文件" class="headerlink" title="列出目录下的文件"></a>列出目录下的文件</h3><p>这仅适用于嵌入式文件管理器。</p><p>一些文件夹可能非常大。为了有效地列出文件，我们使用非传统方式来迭代文件。每个分页都提供一个“ lastFileName”和一个“ limit = x”。文件管理器在O（log（n））时间中找到“ lastFileName”，并检索接下来的x个文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">List files under a directory</span><br><span class="line">This is for embedded filer only.</span><br><span class="line"></span><br><span class="line">Some folder can be very large. To efficiently list files, we use a non-traditional way to iterate files. Every pagination you provide a "lastFileName", and a "limit=x". The filer locate the "lastFileName" in O(log(n)) time, and retrieve the next x files.</span><br><span class="line"></span><br><span class="line">curl  "http://localhost:8888/javascript/?pretty=y&amp;lastFileName=new_name.js&amp;limit=2"</span><br><span class="line">&#123;</span><br><span class="line">  "Directory": "/javascript/",</span><br><span class="line">  "Files": [</span><br><span class="line">    &#123;</span><br><span class="line">      "name": "report.js",</span><br><span class="line">      "fid": "7,0254f1f3fd"</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><h4 id="删除文件-1"><a href="#删除文件-1" class="headerlink" title="删除文件"></a>删除文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> curl -X DELETE http://localhost:8888/path/to/file</span></span><br></pre></td></tr></table></figure><h4 id="删除文件夹"><a href="#删除文件夹" class="headerlink" title="删除文件夹"></a>删除文件夹</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// recursively delete all files and folders under a path</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> curl -X DELETE http://localhost:8888/path/to/dir?recursive=<span class="literal">true</span></span></span><br><span class="line">// recursively delete everything, ignoring any recursive error</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> curl -X DELETE http://localhost:8888/path/to/dir?recursive=<span class="literal">true</span>&amp;ignoreRecursiveError=<span class="literal">true</span></span></span><br><span class="line"></span><br><span class="line">// For Experts Only: remove filer directories only, without removing data chunks. </span><br><span class="line">// see https://github.com/chrislusf/seaweedfs/pull/1153</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> curl -X DELETE http://localhost:8888/path/to?recursive=<span class="literal">true</span>&amp;skipChunkDeletion=<span class="literal">true</span></span></span><br></pre></td></tr></table></figure><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>Filer具有连接到Master的持久客户端，以获取所有卷的位置更新。没有回调来查找卷ID位置。官方说明参见：<a href="https://github.com/chrislusf/seaweedfs/wiki/Directories-and-Files#architecture" target="_blank" rel="noopener">https://github.com/chrislusf/seaweedfs/wiki/Directories-and-Files#architecture</a></p><h3 id="mount挂载"><a href="#mount挂载" class="headerlink" title="mount挂载"></a>mount挂载</h3><p>weed mount 功能需要配合 Filer 才能使用，这样可以在服务器上用命令行操作文件。支持的操作如下：</p><ul><li>file read / write</li><li>create new file</li><li>mkdir</li><li>list</li><li>remove</li><li>rename</li><li>chmod</li><li>chown</li><li>soft link</li><li>display free disk space</li></ul><p>详见：<a href="https://github.com/chrislusf/seaweedfs/wiki/Mount" target="_blank" rel="noopener">https://github.com/chrislusf/seaweedfs/wiki/Mount</a></p><h3 id="Amazon-S3-API"><a href="#Amazon-S3-API" class="headerlink" title="Amazon S3 API"></a>Amazon S3 API</h3><p>为了与<code>Amazon S3 API</code>兼容，提供了单独的<code>weed s3</code>命令。与在云上操作文件相比，这在读取或写入文件时提供了更快的访问权限。</p><p><code>weed s3</code>将启动无状态网关服务器，以将<code>Amazon S3 API</code>桥接到<code>SeaweedFS Filer</code>。为了方便起见，<code>weed server -s3</code>将启动主服务器，卷服务器，文件管理器和S3网关。</p><p>每个存储桶都存储在一个集合中，并且默认情况下映射到文件夹<code>/ buckets / &lt;bucket_name&gt;</code>。</p><p>通过删除整个集合，可以有效地删除存储桶。</p><p>当前，支持以下API。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// Object operations</span><br><span class="line">* PutObject</span><br><span class="line">* GetObject</span><br><span class="line">* HeadObject</span><br><span class="line">* CopyObject</span><br><span class="line">* DeleteObject</span><br><span class="line">* ListObjectsV2</span><br><span class="line">* ListObjectsV1</span><br><span class="line"></span><br><span class="line">// Bucket operations</span><br><span class="line">* PutBucket</span><br><span class="line">* DeleteBucket</span><br><span class="line">* HeadBucket</span><br><span class="line">* ListBuckets</span><br><span class="line"></span><br><span class="line">// Multipart upload operations</span><br><span class="line">* NewMultipartUpload</span><br><span class="line">* CompleteMultipartUpload</span><br><span class="line">* AbortMultipartUpload</span><br><span class="line">* ListMultipartUploads</span><br><span class="line">* CopyObjectPart</span><br></pre></td></tr></table></figure><h1 id="0x06-异步备份"><a href="#0x06-异步备份" class="headerlink" title="0x06 异步备份"></a>0x06 异步备份</h1><h2 id="异步复制到另一个Filer"><a href="#异步复制到另一个Filer" class="headerlink" title="异步复制到另一个Filer"></a>异步复制到另一个Filer</h2><p>应该有两个Seaweed文件系统正在运行，可能跨数据中心运行。每个服务器都应具有其文件服务器，主服务器和卷服务器。</p><p><img src="https://github.com/chrislusf/seaweedfs/wiki/FilerAsyncReplication.png" alt="架构图"></p><p>详见：<a href="https://github.com/chrislusf/seaweedfs/wiki/Async-Replication-to-another-Filer" target="_blank" rel="noopener">https://github.com/chrislusf/seaweedfs/wiki/Async-Replication-to-another-Filer</a></p><h2 id="备份到云"><a href="#备份到云" class="headerlink" title="备份到云"></a>备份到云</h2><p>诸如Amazon S3，Google Cloud Storage，Azure，Backblaze B2等云存储选项非常适合备份。</p><p>Filer中的每个文件更改都会触发通知发送到消息队列。<code>weed replicate</code>过程将从消息队列中读取，读取实际文件内容，然后将更新发送到云接收器。</p><p><img src="https://github.com/chrislusf/seaweedfs/wiki/FilerAsyncBackupToCloud.png" alt="结构图"></p><p>详见：<a href="https://github.com/chrislusf/seaweedfs/wiki/Backup-to-Cloud" target="_blank" rel="noopener">https://github.com/chrislusf/seaweedfs/wiki/Backup-to-Cloud</a></p><h1 id="0x07-进阶"><a href="#0x07-进阶" class="headerlink" title="0x07 进阶"></a>0x07 进阶</h1><h2 id="复写配置"><a href="#复写配置" class="headerlink" title="复写配置"></a>复写配置</h2><p>SeaweedFS可以支持复制。复制不是在文件级别而是在卷级别实现的。</p><h3 id="怎么用？"><a href="#怎么用？" class="headerlink" title="怎么用？"></a>怎么用？</h3><ol><li><p>start weed master, and optionally specify the default replication type</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./weed master -defaultReplication=001</span><br></pre></td></tr></table></figure></li><li><p>start volume servers as this:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./weed volume -port=8081 -dir=/tmp/1 -max=100 -mserver="master_address:9333" -dataCenter=dc1 -rack=rack1</span><br><span class="line">./weed volume -port=8082 -dir=/tmp/2 -max=100 -mserver="master_address:9333" -dataCenter=dc1 -rack=rack1</span><br></pre></td></tr></table></figure></li></ol><p>On another rack,</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./weed volume -port=8081 -dir=/tmp/1 -max=100 -mserver="master_address:9333" -dataCenter=dc1 -rack=rack2</span><br><span class="line">./weed volume -port=8082 -dir=/tmp/2 -max=100 -mserver="master_address:9333" -dataCenter=dc1 -rack=rack2</span><br></pre></td></tr></table></figure><p>No change to Submitting, Reading, and Deleting files.</p><h3 id="复写类型的含义"><a href="#复写类型的含义" class="headerlink" title="复写类型的含义"></a>复写类型的含义</h3><p><em>Note: This subject to change.</em></p><table><thead><tr><th>Value</th><th>Meaning</th></tr></thead><tbody><tr><td>000</td><td>no replication, just one copy</td></tr><tr><td>001</td><td>replicate once on the same rack</td></tr><tr><td>010</td><td>replicate once on a different rack in the same data center</td></tr><tr><td>100</td><td>replicate once on a different data center</td></tr><tr><td>200</td><td>replicate twice on two other different data center</td></tr><tr><td>110</td><td>replicate once on a different rack, and once on a different data center</td></tr><tr><td>…</td><td>…</td></tr></tbody></table><p>So if the replication type is xyz</p><table><thead><tr><th>Column</th><th>Meaning</th></tr></thead><tbody><tr><td><strong>x</strong></td><td>number of replica in other data centers</td></tr><tr><td><strong>y</strong></td><td>number of replica in other racks in the same data center</td></tr><tr><td><strong>z</strong></td><td>number of replica in other servers in the same rack</td></tr></tbody></table><p>x,y,z each can be 0, 1, or 2. So there are 9 possible replication types, and can be easily extended. Each replication type will physically create x+y+z+1 copies of volume data files.</p><h2 id="大文件处理"><a href="#大文件处理" class="headerlink" title="大文件处理"></a>大文件处理</h2><p>为了支持大文件，SeaweedFS支持以下两种文件：</p><ul><li>块文件。每个块文件实际上只是SeaweedFS的普通文件。</li><li>块清单。一个带有所有块列表的简单json文件。</li></ul><p>更多详见：<a href="https://github.com/chrislusf/seaweedfs/wiki/Large-File-Handling" target="_blank" rel="noopener">https://github.com/chrislusf/seaweedfs/wiki/Large-File-Handling</a></p><h2 id="安全配置"><a href="#安全配置" class="headerlink" title="安全配置"></a>安全配置</h2><p><code>weed scaffold -config=security</code> 生成<code>security.toml</code></p><p><code>security.toml</code>文件示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Put this file to one of the location, with descending priority</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    ./security.toml</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    <span class="variable">$HOME</span>/.seaweedfs/security.toml</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    /etc/seaweedfs/security.toml</span></span><br><span class="line"></span><br><span class="line">[jwt.signing]</span><br><span class="line">key = "blahblahblahblah"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> all grpc tls authentications are mutual </span></span><br><span class="line">[grpc]</span><br><span class="line">ca = "/Users/ghostsf/.seaweedfs/out/SeaweedFS_CA.crt"</span><br><span class="line"></span><br><span class="line">[grpc.volume]</span><br><span class="line">cert = "/Users/ghostsf/.seaweedfs/out/volume01.crt"</span><br><span class="line">key  = "/Users/ghostsf/.seaweedfs/out/volume01.key"</span><br><span class="line"></span><br><span class="line">[grpc.master]</span><br><span class="line">cert = "/Users/ghostsf/.seaweedfs/out/master01.crt"</span><br><span class="line">key  = "/Users/ghostsf/.seaweedfs/out/master01.key"</span><br><span class="line"></span><br><span class="line">[grpc.filer]</span><br><span class="line">cert = "/Users/ghostsf/.seaweedfs/out/filer01.crt"</span><br><span class="line">key  = "/Users/ghostsf/.seaweedfs/out/filer01.key"</span><br><span class="line"></span><br><span class="line">[grpc.client]</span><br><span class="line">cert = "/Users/ghostsf/.seaweedfs/out/client01.crt"</span><br><span class="line">key  = "/Users/ghostsf/.seaweedfs/out/client01.key"</span><br></pre></td></tr></table></figure><h1 id="0x08-各语言的客户端"><a href="#0x08-各语言的客户端" class="headerlink" title="0x08 各语言的客户端"></a>0x08 各语言的客户端</h1><p>目前官方提供了足够的Api，各种语言的客户端也都有了。</p><p>详见：<a href="https://github.com/chrislusf/seaweedfs/wiki/Client-Libraries" target="_blank" rel="noopener">https://github.com/chrislusf/seaweedfs/wiki/Client-Libraries</a></p><h1 id="0x09-不足与问题"><a href="#0x09-不足与问题" class="headerlink" title="0x09 不足与问题"></a>0x09 不足与问题</h1><ol><li>seaweedfs 采用的是同步式复写有以下几个问题：</li></ol><ul><li><p>当在某个volume-server 下线又上线恢复的情况下，没有自动的同步机制</p></li><li><p>同步复写需要等待每个节点都复写成功，效率相对较低</p></li><li><p>虽然节点的上下线会快速通过心跳通知master节点，但是仍然存在一定的延迟，期间Volume-Server在复写的时候可能会出现因为复写已经下线的volume-server导致上传失败的情况</p></li></ul><ol start="2"><li>seaweedfs目前在权限管理方面还相对比较弱，目前仅有一个白名单控制机制，来控制外部的读写权限/恶意删除。</li></ol><h1 id="0x0A-遇到问题怎么办"><a href="#0x0A-遇到问题怎么办" class="headerlink" title="0x0A 遇到问题怎么办"></a>0x0A 遇到问题怎么办</h1><ul><li><p><a href="https://github.com/chrislusf/seaweedfs/wiki" target="_blank" rel="noopener">https://github.com/chrislusf/seaweedfs/wiki</a></p></li><li><p><a href="https://github.com/chrislusf/seaweedfs/issues" target="_blank" rel="noopener">https://github.com/chrislusf/seaweedfs/issues</a></p></li><li><p><a href="https://github.com/chrislusf/seaweedfs/community" target="_blank" rel="noopener">https://github.com/chrislusf/seaweedfs/community</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x00-概述&quot;&gt;&lt;a href=&quot;#0x00-概述&quot; class=&quot;headerlink&quot; title=&quot;0x00 概述&quot;&gt;&lt;/a&gt;0x00 概述&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/chrislusf/seaweedfs/master/note/seaweedfs.png&quot; alt=&quot;SeaweedFS Logo&quot;&gt;&lt;/p&gt;&lt;p&gt;Github: &lt;a href=&quot;https://github.com/chrislusf/seaweedfs&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/chrislusf/seaweedfs&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;SeaweedFS is a simple and highly scalable distributed file system, to store and serve billions of files fast! SeaweedFS implements an object store with O(1) disk seek, transparent cloud integration, and an optional Filer with POSIX interface, supporting S3 API, Rack-Aware Erasure Coding for warm storage, FUSE mount, Hadoop compatible, WebDAV.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;SeaweedFS是一个简单且高度可扩展的分布式文件系统，可以快速存储和提供数十亿个文件！SeaweedFS通过 O(1) 磁盘搜索，透明云集成以及带有POSIX接口的可选Filer，实现了对象存储，支持S3 API，用于热存储的机架感知擦除编码，FUSE安装，Hadoop兼容，WebDAV。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术栈" scheme="https://ghostsf.com/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="SeaweedFS" scheme="https://ghostsf.com/tags/SeaweedFS/"/>
    
      <category term="分布式" scheme="https://ghostsf.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="文件系统" scheme="https://ghostsf.com/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>《江湖风云录之民谣》何教授2019 带歌词</title>
    <link href="https://ghostsf.com/qnmlgb/"/>
    <id>https://ghostsf.com/qnmlgb/</id>
    <published>2020-02-22T21:20:08.000Z</published>
    <updated>2020-04-01T09:51:38.587Z</updated>
    
    <content type="html"><![CDATA[<p>《江湖风云录之民谣》何教授2019.5.25 沈阳</p><blockquote><p>给大家配上了歌词，敬请欣赏 = =</p></blockquote><div id="player-qnmlgb"></div><script type="text/javascript">new DPlayer({container:document.getElementById("player-qnmlgb"),video:{url:"https://cdn.ghostsf.com/%E6%B1%9F%E6%B9%96%E9%A3%8E%E4%BA%91%E5%BD%95%E4%B9%8B%E6%B0%91%E8%B0%A3.mp4"}})</script><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《江湖风云录之民谣》何教授2019.5.25 沈阳&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;给大家配上了歌词，敬请欣赏 = =&lt;/p&gt;&lt;/blockquote&gt;&lt;div id=&quot;player-qnmlgb&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;new DPlayer({container:document.getElementById(&quot;player-qnmlgb&quot;),video:{url:&quot;https://cdn.ghostsf.com/%E6%B1%9F%E6%B9%96%E9%A3%8E%E4%BA%91%E5%BD%95%E4%B9%8B%E6%B0%91%E8%B0%A3.mp4&quot;}})&lt;/script&gt;
    
    </summary>
    
    
      <category term="闲言语" scheme="https://ghostsf.com/categories/%E9%97%B2%E8%A8%80%E8%AF%AD/"/>
    
      <category term="创作集" scheme="https://ghostsf.com/categories/%E9%97%B2%E8%A8%80%E8%AF%AD/%E5%88%9B%E4%BD%9C%E9%9B%86/"/>
    
    
      <category term="民谣" scheme="https://ghostsf.com/tags/%E6%B0%91%E8%B0%A3/"/>
    
  </entry>
  
  <entry>
    <title>逆行的伞</title>
    <link href="https://ghostsf.com/%E9%80%86%E8%A1%8C%E7%9A%84%E4%BC%9E/"/>
    <id>https://ghostsf.com/%E9%80%86%E8%A1%8C%E7%9A%84%E4%BC%9E/</id>
    <published>2020-02-14T10:53:01.000Z</published>
    <updated>2020-04-01T09:51:38.591Z</updated>
    
    <content type="html"><![CDATA[<h2 id="逆行的伞"><a href="#逆行的伞" class="headerlink" title="逆行的伞"></a>逆行的伞</h2><blockquote><p>写于2011年8月23日 14时</p></blockquote><p><img src="../images/post/%E9%80%86%E8%A1%8C%E7%9A%84%E4%BC%9E.jpeg" alt="逆行的伞"></p><p>独自<br>撑着一纸的孤单<br>任雨<br>在头顶轻叹<br>我在人群拥挤中逆行<br>渐渐丢了<br>手中握紧的伞<br>依稀<br>我看见水洼中倒映的脸<br>彷徨不安</p><hr><p>独自<br>撑着一纸的茫然<br>任雨<br>掉落无言的悲欢<br>我与人群擦肩而行<br>似乎想起<br>去年身旁的伞<br>如果<br>我期待那一瞬的相视无言<br>不问不管</p><hr><p>独自<br>撑着一纸的遗憾<br>任雨<br>溅湿双脚的蹒跚<br>人群在我的思绪中逆行<br>使我忘了<br>捡起丢落一旁的伞<br>于是<br>我祈祷前方背影的黯淡<br>顾首回盼</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;逆行的伞&quot;&gt;&lt;a href=&quot;#逆行的伞&quot; class=&quot;headerlink&quot; title=&quot;逆行的伞&quot;&gt;&lt;/a&gt;逆行的伞&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;写于2011年8月23日 14时&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;../i
      
    
    </summary>
    
    
      <category term="文艺斋" scheme="https://ghostsf.com/categories/%E6%96%87%E8%89%BA%E6%96%8B/"/>
    
    
      <category term="旧文字" scheme="https://ghostsf.com/tags/%E6%97%A7%E6%96%87%E5%AD%97/"/>
    
  </entry>
  
  <entry>
    <title>git-bundle</title>
    <link href="https://ghostsf.com/git-bundle/"/>
    <id>https://ghostsf.com/git-bundle/</id>
    <published>2020-01-16T09:53:06.000Z</published>
    <updated>2020-04-01T09:51:38.587Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Git-工具-打包-bundle"><a href="#Git-工具-打包-bundle" class="headerlink" title="Git 工具 - 打包 - bundle"></a>Git 工具 - 打包 - bundle</h2><p>虽然我们已经了解了网络传输 Git 数据的常用方法（如 HTTP，SSH 等），但还有另外一种不太常见却又十分有用的方式。</p><p>Git 可以将它的数据“打包”到一个文件中。 这在许多场景中都很有用。 有可能你的网络中断了，但你又希望将你的提交传给你的合作者们。 可能你不在办公网中并且出于安全考虑没有给你接入内网的权限。 可能你的无线、有线网卡坏掉了。 可能你现在没有共享服务器的权限，你又希望通过邮件将更新发送给别人，却不希望通过 format-patch 的方式传输 40 个提交。</p><p>这些情况下 git bundle 就会很有用。 bundle 命令会将 git push 命令所传输的所有内容打包成一个二进制文件，你可以将这个文件通过邮件或者闪存传给其他人，然后解包到其他的仓库中。</p><p>来看看一个简单的例子。 假设你有一个包含两个提交的仓库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git log  </span><br><span class="line">commit 9a466c572fe88b195efd356c3f2bbeccdb504102  </span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;  </span><br><span class="line">Date:   Wed Mar 10 07:34:10 2010 -0800  </span><br><span class="line">    second commit  </span><br><span class="line"></span><br><span class="line">commit b1ec3248f39900d2a406049d762aa68e9641be25  </span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;  </span><br><span class="line">Date:   Wed Mar 10 07:34:01 2010 -0800  </span><br><span class="line">    first commit</span><br></pre></td></tr></table></figure><p>如果你想把这个仓库发送给其他人但你没有其他仓库的权限，或者就是懒得新建一个仓库，你就可以用 git bundle create 命令来打包。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git bundle create repo.bundle HEAD master  </span><br><span class="line">Counting objects: 6, done.  </span><br><span class="line">Delta compression using up to 2 threads.    </span><br><span class="line">Compressing objects: 100% (2&#x2F;2), done.  </span><br><span class="line">Writing objects: 100% (6&#x2F;6), 441 bytes, done.  </span><br><span class="line">Total 6 (delta 0), reused 0 (delta 0)</span><br></pre></td></tr></table></figure><p>然后你就会有一个名为 repo.bundle 的文件，该文件包含了所有重建该仓库 master 分支所需的数据。 在使用 bundle 命令时，你需要列出所有你希望打包的引用或者提交的区间。 如果你希望这个仓库可以在别处被克隆，你应该像例子中那样增加一个 HEAD 引用。</p><p>你可以将这个 repo.bundle 文件通过邮件或者U盘传给别人。</p><p>另一方面，假设别人传给你一个 repo.bundle 文件并希望你在这个项目上工作。 你可以从这个二进制文件中克隆出一个目录，就像从一个 URL 克隆一样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git clone repo.bundle repo  </span><br><span class="line">Initialized empty Git repository in &#x2F;private&#x2F;tmp&#x2F;bundle&#x2F;repo&#x2F;.git&#x2F;  </span><br><span class="line">$ cd repo  </span><br><span class="line">$ git log --oneline  </span><br><span class="line">9a466c5 second commit </span><br><span class="line">b1ec324 first commit</span><br></pre></td></tr></table></figure><p>如果你在打包时没有包含 HEAD 引用，你还需要在命令后指定一个 -b master 或者其他被引入的分支，否则 Git 不知道应该检出哪一个分支。</p><p>现在假设你提交了 3 个修订，并且要用邮件或者U盘将新的提交放在一个包里传回去。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git log --oneline  </span><br><span class="line">71b84da last commit - second repo  </span><br><span class="line">c99cf5b fourth commit - second repo  </span><br><span class="line">7011d3d third commit - second repo  </span><br><span class="line">9a466c5 second commit  </span><br><span class="line">b1ec324 first commit</span><br></pre></td></tr></table></figure><p>首先我们需要确认我们希望被打包的提交区间。 和网络协议不太一样，网络协议会自动计算出所需传输的最小数据集，而我们需要手动计算。 当然你可以像上面那样将整个仓库打包，但最好仅仅打包变更的部分 —— 就是我们刚刚在本地做的 3 个提交。</p><p>为了实现这个目标，你需要计算出差别。 就像我们在 提交区间 介绍的，你有很多种方式去指明一个提交区间。 我们可以使用 origin/master..master 或者 master ^origin/master 之类的方法来获取那 3 个在我们的 master 分支而不在原始仓库中的提交。 你可以用 log 命令来测试。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git log --oneline master ^origin&#x2F;master </span><br><span class="line">71b84da last commit - second repo  </span><br><span class="line">c99cf5b fourth commit - second repo  </span><br><span class="line">7011d3d third commit - second repo</span><br></pre></td></tr></table></figure><p>这样就获取到我们希望被打包的提交列表，让我们将这些提交打包。 我们可以用 git bundle create 命令，加上我们想用的文件名，以及要打包的提交区间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git bundle create commits.bundle master ^9a466c5  </span><br><span class="line">Counting objects: 11, done.  </span><br><span class="line">Delta compression using up to 2 threads.  </span><br><span class="line">Compressing objects: 100% (3&#x2F;3), done.  </span><br><span class="line">Writing objects: 100% (9&#x2F;9), 775 bytes, done.  </span><br><span class="line">Total 9 (delta 0), reused 0 (delta 0)</span><br></pre></td></tr></table></figure><p>现在在我们的目录下会有一个 commits.bundle 文件。 如果我们把这个文件发送给我们的合作者，她可以将这个文件导入到原始的仓库中，即使在这期间已经有其他的工作提交到这个仓库中。</p><p>当她拿到这个包时，她可以在导入到仓库之前查看这个包里包含了什么内容。 bundle verify 命令可以检查这个文件是否是一个合法的 Git 包，是否拥有共同的祖先来导入。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git bundle verify ..&#x2F;commits.bundle  </span><br><span class="line">The bundle contains 1 ref  </span><br><span class="line">71b84daaf49abed142a373b6e5c59a22dc6560dc refs&#x2F;heads&#x2F;master  </span><br><span class="line">The bundle requires these 1 ref  </span><br><span class="line">9a466c572fe88b195efd356c3f2bbeccdb504102 second commit  </span><br><span class="line">..&#x2F;commits.bundle is okay</span><br></pre></td></tr></table></figure><p>如果打包工具仅仅把最后两个提交打包，而不是三个，原始的仓库是无法导入这个包的，因为这个包缺失了必要的提交记录。这时候 verify 的输出类似：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git bundle verify ..&#x2F;commits-bad.bundle  </span><br><span class="line">error: Repository lacks these prerequisite commits:   </span><br><span class="line">error: 7011d3d8fc200abe0ad561c011c3852a4b7bbe95 third commit - second repo</span><br></pre></td></tr></table></figure><p>而我们的第一个包是合法的，所以我们可以从这个包里提取出提交。 如果你想查看这边包里可以导入哪些分支，同样有一个命令可以列出这些顶端：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git bundle list-heads ..&#x2F;commits.bundle  </span><br><span class="line">71b84daaf49abed142a373b6e5c59a22dc6560dc refs&#x2F;heads&#x2F;master</span><br></pre></td></tr></table></figure><p>verify 子命令同样可以告诉你有哪些顶端。 该功能的目的是查看哪些是可以被拉入的，所以你可以使用 fetch 或者 pull 命令从包中导入提交。 这里我们要从包中取出 master 分支到我们仓库中的 other-master 分支：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch ..&#x2F;commits.bundle master:other-master  </span><br><span class="line">From ..&#x2F;commits.bundle  </span><br><span class="line"> * [new branch]      master     -&gt; other-master</span><br></pre></td></tr></table></figure><p>可以看到我们已经将提交导入到 other-master 分支，以及在这期间我们自己在 master 分支上的提交。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git log --oneline --decorate --graph --all  </span><br><span class="line">* 8255d41 (HEAD, master) third commit - first repo  </span><br><span class="line">| * 71b84da (other-master) last commit - second repo  </span><br><span class="line">| * c99cf5b fourth commit - second repo  </span><br><span class="line">| * 7011d3d third commit - second repo  </span><br><span class="line">|&#x2F;  </span><br><span class="line">* 9a466c5 second commit  </span><br><span class="line">* b1ec324 first commit</span><br></pre></td></tr></table></figure><p>因此，当你在没有合适的网络或者可共享仓库的情况下，git bundle 很适合用于共享或者网络类型的操作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Git-工具-打包-bundle&quot;&gt;&lt;a href=&quot;#Git-工具-打包-bundle&quot; class=&quot;headerlink&quot; title=&quot;Git 工具 - 打包 - bundle&quot;&gt;&lt;/a&gt;Git 工具 - 打包 - bundle&lt;/h2&gt;&lt;p&gt;虽然我们已经
      
    
    </summary>
    
    
      <category term="技术栈" scheme="https://ghostsf.com/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="git" scheme="https://ghostsf.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Vlog0x01 - IKBC F87 时光机 清洗记</title>
    <link href="https://ghostsf.com/vlog1/"/>
    <id>https://ghostsf.com/vlog1/</id>
    <published>2020-01-03T09:39:38.000Z</published>
    <updated>2020-04-01T09:51:38.587Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vlog0x01-IKBC-F87-时光机-清洗记"><a href="#Vlog0x01-IKBC-F87-时光机-清洗记" class="headerlink" title="Vlog0x01 - IKBC F87 时光机 清洗记"></a>Vlog0x01 - IKBC F87 时光机 清洗记</h2><p><a href="https://www.bilibili.com/video/av81643587/" target="_blank" rel="noopener">https://www.bilibili.com/video/av81643587/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Vlog0x01-IKBC-F87-时光机-清洗记&quot;&gt;&lt;a href=&quot;#Vlog0x01-IKBC-F87-时光机-清洗记&quot; class=&quot;headerlink&quot; title=&quot;Vlog0x01 - IKBC F87 时光机 清洗记&quot;&gt;&lt;/a&gt;Vlog0x01 
      
    
    </summary>
    
    
      <category term="创作集" scheme="https://ghostsf.com/categories/%E5%88%9B%E4%BD%9C%E9%9B%86/"/>
    
    
      <category term="vlog" scheme="https://ghostsf.com/tags/vlog/"/>
    
  </entry>
  
  <entry>
    <title>未知生物圣诞游行</title>
    <link href="https://ghostsf.com/christmas/"/>
    <id>https://ghostsf.com/christmas/</id>
    <published>2019-12-26T13:49:41.000Z</published>
    <updated>2020-04-01T09:51:38.587Z</updated>
    
    <content type="html"><![CDATA[<h2 id="未知生物圣诞游行-直通"><a href="#未知生物圣诞游行-直通" class="headerlink" title="未知生物圣诞游行 直通"></a><a href="https://www.bilibili.com/video/av80718385/" target="_blank" rel="noopener">未知生物圣诞游行 直通</a></h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;未知生物圣诞游行-直通&quot;&gt;&lt;a href=&quot;#未知生物圣诞游行-直通&quot; class=&quot;headerlink&quot; title=&quot;未知生物圣诞游行 直通&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.bilibili.com/video/av80718385/&quot; 
      
    
    </summary>
    
    
      <category term="创作集" scheme="https://ghostsf.com/categories/%E5%88%9B%E4%BD%9C%E9%9B%86/"/>
    
    
      <category term="圣诞节" scheme="https://ghostsf.com/tags/%E5%9C%A3%E8%AF%9E%E8%8A%82/"/>
    
      <category term="vlog" scheme="https://ghostsf.com/tags/vlog/"/>
    
  </entry>
  
  <entry>
    <title>修改git历史提交信息</title>
    <link href="https://ghostsf.com/git-commit-change/"/>
    <id>https://ghostsf.com/git-commit-change/</id>
    <published>2019-12-26T10:33:53.000Z</published>
    <updated>2020-04-01T09:51:38.587Z</updated>
    
    <content type="html"><![CDATA[<p>修复 git 历史提交信息<br>To change the name and/or email address recorded in existing commits, you must rewrite the entire history of your Git repository.</p><p>为了修改 commit 的作者邮箱地址，你必须重写整个 git 仓库历史</p><p>Warning: This action is destructive to your repository’s history. If you’re collaborating on a repository with others, it’s considered bad practice to rewrite published history. You should only do this in an emergency.</p><p>警告： 这个操作会破坏你的仓库历史， 如果你和别人在协同开发这个仓库，重写已发布的历史记录是一个不好的操作。建议只在紧急情况操作</p><p>操作步骤：</p><a id="more"></a><p>打开 bash</p><p>Create a fresh, bare clone of your repository: （新建一个全新的仓库信息：)</p><pre><code>git clone --bare https://github.com/user/repo.gitcd repo.git</code></pre><p>Copy and paste the script, replacing the following variables based on the information you gathered: (在终端复制并粘贴以下脚本，并将以下的变量修改为你需要的)</p><p><strong>OLD_EMAIL</strong></p><p><strong>CORRECT_NAME</strong></p><p><strong>CORRECT_EMAIL</strong></p><p>脚本信息：</p><p><a href="https://gist.github.com/ghostsf/de39ebde3a50b0fcaf4f3de172940969" target="_blank" rel="noopener">git-commit-change.sh</a></p><p>Press Enter to run the script.（按下 enter 键来运行这个脚本</p><p>Review the new Git history for errors.(校对新的 git 仓库历史）</p><p>Push the corrected history to GitHub:（将修改后的仓库历史推到远程）</p><p>git push –force –tags origin ‘refs/heads/*’<br>Clean up the temporary clone: (删除这个仓库)</p><p>cd ..<br>rm -rf repo.git</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;修复 git 历史提交信息&lt;br&gt;To change the name and/or email address recorded in existing commits, you must rewrite the entire history of your Git repository.&lt;/p&gt;&lt;p&gt;为了修改 commit 的作者邮箱地址，你必须重写整个 git 仓库历史&lt;/p&gt;&lt;p&gt;Warning: This action is destructive to your repository’s history. If you’re collaborating on a repository with others, it’s considered bad practice to rewrite published history. You should only do this in an emergency.&lt;/p&gt;&lt;p&gt;警告： 这个操作会破坏你的仓库历史， 如果你和别人在协同开发这个仓库，重写已发布的历史记录是一个不好的操作。建议只在紧急情况操作&lt;/p&gt;&lt;p&gt;操作步骤：&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术栈" scheme="https://ghostsf.com/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="git" scheme="https://ghostsf.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>tar命令参数</title>
    <link href="https://ghostsf.com/tar/"/>
    <id>https://ghostsf.com/tar/</id>
    <published>2019-12-24T17:07:19.000Z</published>
    <updated>2020-04-01T09:51:38.587Z</updated>
    
    <content type="html"><![CDATA[<h3 id="tar命令参数说明"><a href="#tar命令参数说明" class="headerlink" title="tar命令参数说明"></a>tar命令参数说明</h3><p>-c : 建立一个打包文件；</p><p>-x ：解开一个打包文件；</p><p>-t ：查看 tar包里面的文件；</p><p>（特别注意，在选择参数时，c/x/t仅能存在一个，不可同时存在，因为不可能同时压缩与解压缩。）</p><p>-z ：打包后用gzip压缩，生成.tar.gz文件；</p><p>-j ：打包后用zip2压缩，生成.tar.bz2文件；</p><p>-v ：压缩的过程中显示文件；</p><p>-f ：使用文件名，请留意，在f之后要立即接文件名，不要再加其它参数；</p><p>-p ：保持原文件的属性；</p><p>-P ：使用绝对路径来压缩；</p><p>-N ：设定日期(yyyy/mm/dd)，比后面接的日期还要新的文件才会被打包进新建的文件中；</p><p>–exclude FILE：在打包的过程中，不要将FILE打包。</p><blockquote><ul><li><ul><li>可能我用得少，老记不住 这里初步整理下</li></ul></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;tar命令参数说明&quot;&gt;&lt;a href=&quot;#tar命令参数说明&quot; class=&quot;headerlink&quot; title=&quot;tar命令参数说明&quot;&gt;&lt;/a&gt;tar命令参数说明&lt;/h3&gt;&lt;p&gt;-c : 建立一个打包文件；&lt;/p&gt;&lt;p&gt;-x ：解开一个打包文件；&lt;/p&gt;&lt;p&gt;-
      
    
    </summary>
    
    
      <category term="技术栈" scheme="https://ghostsf.com/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="linux" scheme="https://ghostsf.com/tags/linux/"/>
    
      <category term="tar" scheme="https://ghostsf.com/tags/tar/"/>
    
  </entry>
  
  <entry>
    <title>自建maven私有仓库实践</title>
    <link href="https://ghostsf.com/nexus/"/>
    <id>https://ghostsf.com/nexus/</id>
    <published>2019-12-24T15:20:35.000Z</published>
    <updated>2020-04-01T09:51:38.587Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>记录一次自建maven私有仓库的过程 = = ， 其实是为了凑个更新</p></blockquote><h2 id="0x01-仓库管理软件"><a href="#0x01-仓库管理软件" class="headerlink" title="0x01 仓库管理软件"></a>0x01 仓库管理软件</h2><p>目前比较流行的有Apache基金会的 Archiva，JFrog 的 Artifactory ，Sonatypec 的 Nexus</p><h2 id="0x02-环境"><a href="#0x02-环境" class="headerlink" title="0x02 环境"></a>0x02 环境</h2><p>要求 Java 8 Runtime Environment或者以上</p><h2 id="0x03-下载运行Nexus"><a href="#0x03-下载运行Nexus" class="headerlink" title="0x03 下载运行Nexus"></a>0x03 下载运行Nexus</h2><p>去 <a href="https://help.sonatype.com/repomanager3/download/download-archives---repository-manager-3" target="_blank" rel="noopener">官网</a> 根据你的操作系统选择下载</p><p>进入bin目录，运行即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Unix &amp; OS X</span><br><span class="line">.&#x2F;nexus run</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Windows  </span><br><span class="line">nexus.exe &#x2F;run</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nexus run 前台运行，可以实时查看运行log</span><br><span class="line"></span><br><span class="line">nexus start 后台运行</span><br><span class="line"></span><br><span class="line">nexus stop 关闭</span><br></pre></td></tr></table></figure><p>默认端口: 8081</p><p>默认的管理员账号密码为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">username：admin</span><br><span class="line">password：admin123</span><br></pre></td></tr></table></figure><p>nexus3 安全性提高了些，admin的密码在<code>~/sonatype-work/nexus3/admin.password</code>文件里</p><h2 id="0x04-配置"><a href="#0x04-配置" class="headerlink" title="0x04 配置"></a>0x04 配置</h2><p>配置文件地址</p><p><code>./etc/nexus-default.properties</code> 可配置端口等参数</p><p><code>./bin/nexus.vmoptions</code> 可配置数据存储的目录以及内存参数等</p><h2 id="0x05-其他配置"><a href="#0x05-其他配置" class="headerlink" title="0x05 其他配置"></a>0x05 其他配置</h2><p><strong>服务自启</strong></p><p>在/etc/systemd/system/下创建nexus.service文件</p><p><code>vi /etc/systemd/system/nexus.service</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line"></span><br><span class="line">Description&#x3D;nexus service</span><br><span class="line"></span><br><span class="line">After&#x3D;network.target</span><br><span class="line">  </span><br><span class="line">[Service]</span><br><span class="line"></span><br><span class="line">Type&#x3D;forking</span><br><span class="line"></span><br><span class="line">LimitNOFILE&#x3D;65536</span><br><span class="line"></span><br><span class="line">ExecStart&#x3D;~&#x2F;bin&#x2F;nexus start</span><br><span class="line"></span><br><span class="line">ExecStop&#x3D;~&#x2F;bin&#x2F;nexus stop</span><br><span class="line"></span><br><span class="line">User&#x3D;nexus</span><br><span class="line"></span><br><span class="line">Restart&#x3D;on-abort</span><br><span class="line">  </span><br><span class="line">[Install]</span><br><span class="line"></span><br><span class="line">WantedBy&#x3D;multi-user.target</span><br></pre></td></tr></table></figure><p><strong>systemctl命令</strong></p><p>更新systemctl</p><p><code>sudo systemctl daemon-reload</code></p><p>设置开机启动</p><p><code>sudo systemctl enable nexus.service</code></p><p>启动nexus服务</p><p><code>sudo systemctl start nexus.service</code></p><p>查看nexus服务状态</p><p><code>sudo systemctl status nexus.service</code></p><p>查看日志</p><p><code>tail -f ~/sonatype-work/nexus3/log/nexus.log</code></p><h2 id="0x06-使用配置"><a href="#0x06-使用配置" class="headerlink" title="0x06 使用配置"></a>0x06 使用配置</h2><p><strong>maven</strong></p><p><strong>maven发布包</strong></p><p>pom.xml 参考</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;distributionManagement&gt;</span><br><span class="line"></span><br><span class="line">    &lt;repository&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;id&gt;nexus-releases&lt;&#x2F;id&gt;</span><br><span class="line">        </span><br><span class="line">        &lt;name&gt;private-nexus-library-releases&lt;&#x2F;name&gt;</span><br><span class="line">        </span><br><span class="line">        &lt;url&gt;http:&#x2F;&#x2F;&#123;host&#125;&#x2F;repository&#x2F;maven-releases&#x2F;&lt;&#x2F;url&gt;</span><br><span class="line">        </span><br><span class="line">    &lt;&#x2F;repository&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;snapshotRepository&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;id&gt;nexus-snapshots&lt;&#x2F;id&gt;</span><br><span class="line">        </span><br><span class="line">        &lt;name&gt;private-nexus-library-snapshots&lt;&#x2F;name&gt;</span><br><span class="line">        </span><br><span class="line">        &lt;url&gt;http:&#x2F;&#x2F;&#123;host&#125;&#x2F;repository&#x2F;maven-snapshots&#x2F;&lt;&#x2F;url&gt;</span><br><span class="line">        </span><br><span class="line">    &lt;&#x2F;snapshotRepository&gt;</span><br><span class="line">&lt;&#x2F;distributionManagement&gt;</span><br></pre></td></tr></table></figure><p>maven settings.xml 参考</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;servers&gt;</span><br><span class="line"></span><br><span class="line">&lt;server&gt;</span><br><span class="line"></span><br><span class="line">  &lt;id&gt;nexus-releases&lt;&#x2F;id&gt;</span><br><span class="line"></span><br><span class="line">  &lt;username&gt;username&lt;&#x2F;username&gt;</span><br><span class="line"></span><br><span class="line">  &lt;password&gt;password&lt;&#x2F;password&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;server&gt;</span><br><span class="line"></span><br><span class="line">&lt;server&gt;</span><br><span class="line"></span><br><span class="line">  &lt;id&gt;nexus-snapshots&lt;&#x2F;id&gt;</span><br><span class="line"></span><br><span class="line">  &lt;username&gt;username&lt;&#x2F;username&gt;</span><br><span class="line"></span><br><span class="line">  &lt;password&gt;password&lt;&#x2F;password&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;server&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;servers&gt;</span><br></pre></td></tr></table></figure><p>*<em>maven使用 *</em></p><p>mirrors add</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-private<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus private<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://&#123;host&#125;/repository/maven-public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure><p>ps：若设置了不允许匿名用户访问<br>则使用远程仓库的时候需要使用鉴权URL</p><p>eg:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-private<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus private<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://&#123;username&#125;:&#123;password&#125;@&#123;host&#125;/repository/maven-public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure><p>// todo 还有很多要整理 有空出个相关专题文章吧</p><h2 id="0x07-注意事项"><a href="#0x07-注意事项" class="headerlink" title="0x07 注意事项"></a>0x07 注意事项</h2><p><strong>修改运行用户</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">WARNING: ************************************************************</span><br><span class="line"></span><br><span class="line">WARNING: Detected execution as "root" user.  This is NOT recommended!</span><br><span class="line"></span><br><span class="line">WARNING: ************************************************************</span><br></pre></td></tr></table></figure><p>创建一个单独的用户进行运行，安全一些</p><p><code>adduser nexus</code></p><p><code>passwd nexus</code></p><p>然后修改nexus为运行用户</p><p><code>vi ./bin/nexus.rc</code></p><p>取消注释，并修改为如下内容</p><p><code>run_as_user=&quot;nexus&quot;</code></p><p>修改nexus3文件的所有者</p><p><code>chown -R nexus:nexus ~/nexus3/</code></p><p><strong>备份迁移</strong></p><p>默认配置 nexus的数据都在此目录下</p><p><code>sonatype-work</code></p><p>该目录可在<code>./bin/nexus.vmoptions</code>自定义配置</p><p>需要备份迁移，只要打包这个目录即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;记录一次自建maven私有仓库的过程 = = ， 其实是为了凑个更新&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&quot;0x01-仓库管理软件&quot;&gt;&lt;a href=&quot;#0x01-仓库管理软件&quot; class=&quot;headerlink&quot; title=&quot;0x01
      
    
    </summary>
    
    
      <category term="技术栈" scheme="https://ghostsf.com/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="maven" scheme="https://ghostsf.com/tags/maven/"/>
    
      <category term="nexus" scheme="https://ghostsf.com/tags/nexus/"/>
    
      <category term="私有仓库" scheme="https://ghostsf.com/tags/%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>免费BT离线下载收集</title>
    <link href="https://ghostsf.com/bt/"/>
    <id>https://ghostsf.com/bt/</id>
    <published>2019-12-23T11:41:40.000Z</published>
    <updated>2020-04-01T09:51:38.587Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th align="left">名称</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left">OffCloud</td><td align="left">单文件无限制，总空间 100G</td></tr><tr><td align="left">Streamza</td><td align="left">单文件 1G 限制，队列 1，无法下载回本地，可在线</td></tr><tr><td align="left">BytesLoader</td><td align="left">单文件无限制，队列 2</td></tr><tr><td align="left">FURK</td><td align="left">单文件 2G 限制，队列 2，可在线</td></tr><tr><td align="left">DirectTorrents</td><td align="left">总文件 10G 限制 队列 3</td></tr><tr><td align="left">Zbigz</td><td align="left">单文件 1G 限制，队列 2，限速 150K，7 天保存</td></tr><tr><td align="left">FileStream</td><td align="left">单文件 1G 限制，队列 2，3 天保存</td></tr><tr><td align="left">FilesLoop</td><td align="left">单文件 1G 限制，队列 1</td></tr><tr><td align="left">BitPort</td><td align="left">单文件 1G 限制，队列 1</td></tr><tr><td align="left">Seedr</td><td align="left">单文件 2G 限制，队列 1</td></tr><tr><td align="left">ByteBX</td><td align="left">单文件 100M 限制，队列不限，总空间 2.5G</td></tr><tr><td align="left">TorrentSafe</td><td align="left">单文件无限制，月队列 3，总空间 10G</td></tr><tr><td align="left">2Giga</td><td align="left">单文件 2G 限制，队列 1</td></tr><tr><td align="left">SonicSeedbox</td><td align="left">单文件无限制，天队列 2，总空间 4G</td></tr><tr><td align="left">HiperDown</td><td align="left">单文件无限制，队列 2，总空间 5G</td></tr></tbody></table><blockquote><p>版权声明：转载自 <a href="https://imoe.xyz/post/120.html" target="_blank" rel="noopener">《免费BT离线下载服务汇总》</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th align=&quot;left&quot;&gt;名称&lt;/th&gt;&lt;th align=&quot;left&quot;&gt;介绍&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;OffCloud&lt;/td&gt;&lt;td align=&quot;left&quot;&gt;单文件
      
    
    </summary>
    
    
      <category term="分享境" scheme="https://ghostsf.com/categories/%E5%88%86%E4%BA%AB%E5%A2%83/"/>
    
    
      <category term="BT" scheme="https://ghostsf.com/tags/BT/"/>
    
      <category term="免费" scheme="https://ghostsf.com/tags/%E5%85%8D%E8%B4%B9/"/>
    
  </entry>
  
  <entry>
    <title>群辉玩物下载套件</title>
    <link href="https://ghostsf.com/dsm-xunlei/"/>
    <id>https://ghostsf.com/dsm-xunlei/</id>
    <published>2019-12-06T14:37:43.000Z</published>
    <updated>2020-04-01T09:51:38.587Z</updated>
    
    <content type="html"><![CDATA[<p>正愁黑群辉没有一个给力的下载器的时候。（Transmission 、 docker+aria2 都不是很理想）</p><blockquote><p>9月20日，NAS大厂群晖科技在上海举办了Synology 2020年度大会，会上宣布与迅雷合作，推出“玩物下载”套件。</p></blockquote><p>那么就美滋滋了。</p><blockquote><p>在群晖NAS里，安装玩物套件并且绑定迅雷帐号后，可以直接将下载的多媒体文件存储在NAS里。出门在外时，远程访问DSM操作下载，回到家即可享受大片。</p></blockquote><p>迫不及待地，安装，试用了。</p><p>emm，真香，基本都是满速。有的比pc上的迅雷都要快很多。</p><p>界面很简单，简单得没什么好操作的 = =</p><p><img src="/images/post/dsm-xunlei.png" alt="玩物下载"></p><p>瞄一眼这速度~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;正愁黑群辉没有一个给力的下载器的时候。（Transmission 、 docker+aria2 都不是很理想）&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;9月20日，NAS大厂群晖科技在上海举办了Synology 2020年度大会，会上宣布与迅雷合作，推出“玩物下载”套件。&lt;/p
      
    
    </summary>
    
    
      <category term="分享境" scheme="https://ghostsf.com/categories/%E5%88%86%E4%BA%AB%E5%A2%83/"/>
    
    
      <category term="群辉" scheme="https://ghostsf.com/tags/%E7%BE%A4%E8%BE%89/"/>
    
  </entry>
  
  <entry>
    <title>安利一款游戏《战双帕弥什》</title>
    <link href="https://ghostsf.com/pns-kurogame/"/>
    <id>https://ghostsf.com/pns-kurogame/</id>
    <published>2019-12-06T14:00:09.000Z</published>
    <updated>2020-04-01T09:51:38.587Z</updated>
    
    <content type="html"><![CDATA[<div id="player-pns"></div><script type="text/javascript">new DPlayer({container:document.getElementById("player-pns"),video:{url:"http://cdnstatic.kurogame.com/pns/2.0/images/video1.mp4"}})</script><p>《战双帕弥什》是广州库洛科技有限公司研发的一款末世科幻题材的3D动作手游。你将化身指挥官，带领人类最后的希望——仿生人形「构造体」，共同对抗被「帕弥什」病毒感染的机械大军。运用你的判断力，灵活地滑动指尖，触发不同的技能招式，在世界的终焉打出华丽一战吧！</p><a id="more"></a><h2 id="世界观"><a href="#世界观" class="headerlink" title="世界观"></a>世界观</h2><h3 id="资料001"><a href="#资料001" class="headerlink" title="资料001"></a>资料001</h3><div id="player-1"></div><script type="text/javascript">new DPlayer({container:document.getElementById("player-1"),video:{url:"http://video.zspns.kurogame.com/hd/2f317626420f4cf99f6d8ec4c2b17568.mp4",pic:"http://cdnimg02.kurogame.com/M00/14/82/ChpCl13nYT2ELg1_AAAAAKugTRY122.jpg"}})</script><h3 id="资料002"><a href="#资料002" class="headerlink" title="资料002"></a>资料002</h3><div id="player-2"></div><script type="text/javascript">new DPlayer({container:document.getElementById("player-2"),video:{url:"http://video.zspns.kurogame.com/hd/2f317626420f4cf99f6d8ec4c2b17568.mp4",pic:"http://cdnimg01.kurogame.com/M00/14/82/ChpCl13nao2EPxARAAAAABXzQNo687.jpg"}})</script><h2 id="壁纸欣赏"><a href="#壁纸欣赏" class="headerlink" title="壁纸欣赏"></a>壁纸欣赏</h2><h3 id="丽芙-纯白之花"><a href="#丽芙-纯白之花" class="headerlink" title="丽芙-纯白之花"></a>丽芙-纯白之花</h3><p><img src="/images/post/pns-5.jpg" alt="丽芙-纯白之花"></p><h3 id="比安卡-严霜凛雪"><a href="#比安卡-严霜凛雪" class="headerlink" title="比安卡-严霜凛雪"></a>比安卡-严霜凛雪</h3><p><img src="/images/post/pns-4.jpg" alt="比安卡-严霜凛雪"></p><h3 id="卡列尼娜"><a href="#卡列尼娜" class="headerlink" title="卡列尼娜"></a>卡列尼娜</h3><p><img src="/images/post/pns-1.jpg" alt="卡列尼娜"></p><h3 id="露西亚"><a href="#露西亚" class="headerlink" title="露西亚"></a>露西亚</h3><p><img src="/images/post/pns-2.jpg" alt="露西亚"></p><h3 id="里"><a href="#里" class="headerlink" title="里"></a>里</h3><p><img src="/images/post/pns-3.jpg" alt="里"></p><h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p><a href="https://wiki.biligame.com/zspms/" target="_blank" rel="noopener">直达wiki</a></p><h3 id="上app-store主推了-191209"><a href="#上app-store主推了-191209" class="headerlink" title="上app store主推了 191209"></a>上app store主推了 191209</h3><p><a href="https://apps.apple.com/cn/story/id1484805266" target="_blank" rel="noopener">appstore主推</a></p>]]></content>
    
    <summary type="html">
    
      &lt;div id=&quot;player-pns&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;new DPlayer({container:document.getElementById(&quot;player-pns&quot;),video:{url:&quot;http://cdnstatic.kurogame.com/pns/2.0/images/video1.mp4&quot;}})&lt;/script&gt;&lt;p&gt;《战双帕弥什》是广州库洛科技有限公司研发的一款末世科幻题材的3D动作手游。你将化身指挥官，带领人类最后的希望——仿生人形「构造体」，共同对抗被「帕弥什」病毒感染的机械大军。运用你的判断力，灵活地滑动指尖，触发不同的技能招式，在世界的终焉打出华丽一战吧！&lt;/p&gt;
    
    </summary>
    
    
      <category term="分享境" scheme="https://ghostsf.com/categories/%E5%88%86%E4%BA%AB%E5%A2%83/"/>
    
    
      <category term="游戏" scheme="https://ghostsf.com/tags/%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>Jrebel for android</title>
    <link href="https://ghostsf.com/jrebel-android/"/>
    <id>https://ghostsf.com/jrebel-android/</id>
    <published>2019-11-28T18:07:55.000Z</published>
    <updated>2020-04-01T09:51:38.587Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h3><blockquote><p>Plugins -&gt; Manage Plugin Repositories -&gt; add</p></blockquote><p><code>http://dl.zeroturnaround.com/jrebel-android/plugins/ide-studio/updatePlugins.xml</code></p><h3 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h3><blockquote><p>Install <code>JRebel for Android</code></p></blockquote><h3 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h3><blockquote><p>Activation</p></blockquote><p><code>Group URL:http://idea.lanyus.com/UUID</code></p><p><code>Email:your email</code></p><h3 id="0x04"><a href="#0x04" class="headerlink" title="0x04"></a>0x04</h3><blockquote><p>Run or debug by Jrebel</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;0x01&quot;&gt;&lt;a href=&quot;#0x01&quot; class=&quot;headerlink&quot; title=&quot;0x01&quot;&gt;&lt;/a&gt;0x01&lt;/h3&gt;&lt;blockquote&gt;&lt;p&gt;Plugins -&amp;gt; Manage Plugin Repositories -&amp;gt; add
      
    
    </summary>
    
    
      <category term="技术栈" scheme="https://ghostsf.com/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="AndroidStudio" scheme="https://ghostsf.com/tags/AndroidStudio/"/>
    
  </entry>
  
  <entry>
    <title>善用 Android Studio 的异动管理功能</title>
    <link href="https://ghostsf.com/as-move/"/>
    <id>https://ghostsf.com/as-move/</id>
    <published>2019-11-21T14:38:15.000Z</published>
    <updated>2020-04-01T09:51:38.587Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>看到一篇难得的关于Android Studio 的异动管理功能的说明文章，姑且转载分享之<br>图片还没整理好 太懒了 后续再慢慢整理 完善吧</p></blockquote><p>身为一个开发人员，每天的工作就是在不断地异动 Source Code 中度过。增加新的、修改旧的、删掉不要的，而每一个异动都会对应到特定的目的，像是为了新的需求、修改 Bug、重构程式等等。</p><p>很多时候，异动的目的在工作的过程中是混在一起的，例如开发新功能的同时，也有可能在修正之前的问题。在自己的工作环境中，这些异动混在一起通常都不会有什么问题产生。只不过这些工作的成果终究是要交付出去的，而问题总在于这些目的却不一定是在同一个时间点被交付。如果所有的异动都混在一起，要隔离出需要交付的部份，势必要花费一番工夫才能办得到。</p><p>而这样的工作要靠人工来逐个 Block、逐个 File 来分辨识，不但耗时，同时也极有可能出现疏漏。因为一个修改就有可能牵涉到十几个 Files，再加上 IDE 自动产生或管理的加一加可能就有成百上千之数。自己经手的异动都不一定能精确的掌握，更何况是数量在数倍、完全不是自己产生的内容。</p><p>人工应付不来，就得要靠工具的辅助。就如同在“ <a href="https://www.jianshu.com/p/50ab4a02c19f" target="_blank" rel="noopener">如何写好程序</a> ”一文中提到，善用工具是写好程序的功课之一。以开发 Android 时所使用的 Android Studio 来说，虽然是由 IntelliJ IDEA Community 版本进化而来，但不代表功能上就很阳春。针对本文提到的问题，其实有内建了相当方便的功能，可以协助开发者解决这类工作上的问题。</p><h2 id="Android-Studio-提供的异动管理功能"><a href="#Android-Studio-提供的异动管理功能" class="headerlink" title="Android Studio 提供的异动管理功能"></a>Android Studio 提供的异动管理功能</h2><h3 id="Changelist"><a href="#Changelist" class="headerlink" title="Changelist"></a>Changelist</h3><p>这是一个以 File 为单位，把异动内容给分门别类的功能。透过这个功能，可以把修改过的 File 进行分组。当有异动内容需要被交付时，可以直接以分好的组别为单位交付。像是要进行 Commit 时，则可以指定特定的 Changelist 来 Commit，不在分组内的 Files 则不会受影响。</p><p>要使用这个功能可以先进入 Version Control Tool Window，Menu 的位置在【View -&gt; Tool Windows -&gt; Version Control】。开启之后可以看见如下图示的内容：</p><p>在 Local Changes 的 Tab 中，可以看到有一个 <code>Default</code> 的字样，这就是 Android Studio 预先产生好的 Changelist。如果没有特别指定，所有被异动的 Files 都会被归在这个 Changelist 之下。在操作上可以使用 Tool Window 中左方的按钮来新增一个 Changelist，新增时可设定此 Changelist 为 Active，代表之后所有还没被异动的 File，在异动后都会被归到这个 Changelist 之下。</p><p>要在 Changelist 之间移动 File 也非常地直觉，可以使用拖拉项目的方式，或是在项目上按下滑鼠右键选择【Move to Another Changelist…】即可。</p><p>当要进行 Commit 时，就可以在如下的“Commit Changes”画面中，最上方的下拉清单选择对应的 Changelist。</p><p>选择不同的 Changelist 时，Changelist 的名称会预设成为 Commit Message 的内容。</p><p>由于 Changelist 是以 File 为单位，所以会有一个限制是同一个 File 不能同时归属于二个 Changelist。一旦编辑了不在 Active Changelist 中的 File，Android Studio 就会出现以下的警告：</p><p>可以看见 Tab 上的文件名变成了红色，这是 Android Studio 遇到异动冲突预设的反应，这部份可以透过点选画面中最右方的按钮来调整。</p><p>这时如果只是忘了切换 Active Changelist，可以选择【Ignore】或是【Switch changelist】。但若真的是二个不同的修改项目都异动到同一个 File，那就得选择一个适当的策略。</p><p>当修改的内容不会有交互的影响，也就是说二个修改项目的结果可以共存在同一个 File 之中，则可以选择【Move changes】把 File 移到最先要被 Commit 的 Changelist 中。</p><p>反之，修改的内容是互斥的时候，就要先保留其中一个版本、还原回修改前的状态后，再开始另一个项目的修改。这个方式在 Android Studio 中也有提供了对应的功能来达成，在这篇文章的稍后会提到。</p><p>Changelist 在使用的情境上，还可以用来区隔一定会修改，但却没有要 Commit 的 File。例如有一些程序运行时需要的配置文件，内容中记录的是 Production 的参数，在开发时就必须要进行修改才能做调试。这时就可以预先新增好一个专用的 Changelist，把这类的 Files 在修改之后归进去。未来在 Commit 时才不致一时疏忽，把开发环境的设定参数给 Commit，造成后续生成上的问题。</p><h3 id="Label"><a href="#Label" class="headerlink" title="Label"></a>Label</h3><p>Label 主要是作用在【VCS -&gt; Local History -&gt; Show History】的 Window 上，如下图所示：</p><p>在 Window 的左侧，可以看到第一个和第二个 History 项目中间，夹了一个 Sample Label 的文字，这个文字是使用【VCS -&gt; Local History -&gt; Put Label…】功能放上去的。</p><p>透过这个功能，可以在进行一些实验性的调整之前，先标定好目前 Source Code 状态。当调整不如预期时，就可以不用花精神去回想做了哪些的修改，再一一去做回复。有了 Label 就可以在 History 的清单中找到所标定的 Source Code 状态，使用【Revert】的功能，直接回到调整前的状态，相当地省事又有效率。</p><h3 id="Shelf"><a href="#Shelf" class="headerlink" title="Shelf"></a>Shelf</h3><p>字面上的意义就是架子，是一个用来摆放文件夹的架子。而文件夹则是前面所提到的 Changelist 的快照，所以当 Changelist 发生冲突时，就可以利用 Shelf 把 Changelist 当下的状态保留起来，等到冲突的情况解决了之后，再把原本异动的内容还原回来。</p><p>要把 Changelist 放到架子上，可以从 Menu 中选择【VCS -&gt; Shelve Changes…】。</p><p>可以由上图看到，画面和 Commit 差不多。完成之后，会在 Version Control Tool Window 中多出一个 Shelf 的 Tab，同时被 Shelve 的 Files 会回到异动前的状态。在 Shelf 的 Tab 上，可以管理 Shelve 过的项目，像是 Unshelve、Rename、Delete。</p><p>在 Unshelve 的过程中，如果没有出现内容冲突，则会自动套用 Shelf 中保留的异动状态。如果内容出现冲突时，则会显示以下的 Window，要求决定所需套用的版本：</p><p>Shelf 除了应用在工作项目的切换之外，如果所开发的 Project 有多个 Branch，在 Branch 还没有相互 Merge 之前，也可以使用 Shelf 来转移、把异动过程套用在不同的 Branch 上。这一点在异动的 Files 数量庞大时，就可以显现出效率上差别，一个批次就可以完成工作，不用再一个个 File 来比对，并且担心是否有异动的内容遗漏了。</p><h3 id="Patch"><a href="#Patch" class="headerlink" title="Patch"></a>Patch</h3><p>Patch 可以算是 Shelf 的外带版本，外带去哪？就是把异动的内容带出 Android Studio 的环境之外。使用 Menu 中【VCS -&gt; Create Patch…】的功能，可以把原本要新增到 Shelf 的项目，改为产生一个实体的 File。操作的画面和 Shelve Changes 一模一样，只是在按下 Window 上【Create Patch…】的按钮后，会出现以下的画面，以便指定 File 储存的位置。</p><p>基本上 Shelf 的项目和 Patch 可以互换，在 Tool Window 中 Shelf 的项目上可以触发 Create Patch 的动作，让 Shelf 的项目转成 Patch。反之，也可以在 Shelf 的 Tab 上 Import Patches 成为 Shelf 的项目。在产生 Shelf 项目和 Patch 时，还有一点最大的差异是 Patch 产生之后，并不会将内容回复到异动之前，而是维持修改后的状态。</p><p>从 Menu 中选择【VCS -&gt; Apply Patch…】后，可以把 Patch 的内容套用回目前的工作环境中，套用的过程和 Shelf 差不多，遇到内容冲突时也同样会出现相同的画面，来决定要选用的版本。</p><p>在应用上，Shelf 的项目能做的 Patch 都能做，除此之外 Patch 还可以用来在不同的 Android Studio 环境之间移转。可以用来将工作的状态由公司的环境中移至家中的环境，以便在离开公司之后仍可接续未完成的部份。或者是可以把 Patch 交给不同的开发人员，用来进行协同合作、Review Code 等工作。</p><p>和版本控管工具的比较<br>如果在开发时使用 Git 做为版本控管的工具，其实以上的功能 Git 大多都可以做到。Android Studio 则是在原有的版本控管机制之外，提供不同的选项，对于不熟悉版本控管工具的人来说有莫大的帮助。而对于用惯了原本工具的人来说，要怎么使用还是得看每个人的习惯、对工具的喜好程度。只不过在面对不同的情况之下，多学会一种工具的使用，在应对的策略上也能产生更多的弹性。</p><p>作者：<em>WZ</em></p><p>链接：<a href="https://www.jianshu.com/p/f66e3ad097ad" target="_blank" rel="noopener">https://www.jianshu.com/p/f66e3ad097ad</a></p><p>来源：简书</p><p>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;看到一篇难得的关于Android Studio 的异动管理功能的说明文章，姑且转载分享之&lt;br&gt;图片还没整理好 太懒了 后续再慢慢整理 完善吧&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;身为一个开发人员，每天的工作就是在不断地异动 Source Code
      
    
    </summary>
    
    
      <category term="分享境" scheme="https://ghostsf.com/categories/%E5%88%86%E4%BA%AB%E5%A2%83/"/>
    
    
      <category term="AndroidStudio" scheme="https://ghostsf.com/tags/AndroidStudio/"/>
    
  </entry>
  
  <entry>
    <title>Could not retrieve transation read-only status server &amp;&amp; Communications link failure 异常</title>
    <link href="https://ghostsf.com/mybatis-mysql-error/"/>
    <id>https://ghostsf.com/mybatis-mysql-error/</id>
    <published>2019-11-04T10:46:36.000Z</published>
    <updated>2020-04-01T09:51:38.587Z</updated>
    
    <content type="html"><![CDATA[<p>上线的项目遇到一个问题。异常信息如下：</p><p>``</p><p>SQLException: Could not retrieve transation read-only status server</p><p>……</p><p>Caused by: com.mysql.jdbc.exceptions.jdbc4.CommunicationsException: Communications link failure</p><p>``</p><p>这两个异常问题，可以联想到的常见问题，无非是事务的问题或者是数据库连接的问题了。</p><p>事务方面 检查了mysql的事务隔离级别：</p><p><code>SHOW VARIABLES LIKE &#39;%iso%&#39;;</code></p><p>返回结果是：</p><p><code>READ-COMMITTED</code></p><blockquote><p>当数据库隔离级别为REPEATABLE-READ时，查询一个select语句也算是事物的开始。</p></blockquote><p>那这就不是这个原因导致的了。</p><p>再看连接的问题，</p><p>看一下数据库时间相关的设置：</p><p><code>show variables like &#39;%timeout%&#39;</code></p><p>返回结果是：</p><p>``</p><p>connect_timeout 10</p><p>delayed_insert_timeout 300</p><p>failover_resend_timeout</p><p>have_statement_timeout YES</p><p>innodb_flush_log_at_timeout 1</p><p>innodb_lock_wait_timeout 50</p><p>innodb_rollback_on_timeout OFF</p><p>interactive_timeout 7200</p><p>lock_wait_timeout 31536000</p><p>net_read_timeout 30</p><p>net_write_timeout 60</p><p>rocksdb_io_write_timeout 0</p><p>rocksdb_lock_wait_timeout 2</p><p>rpl_semi_sync_master_timeout 10000</p><p>rpl_semi_sync_slave_kill_conn_timeout 5</p><p>rpl_stop_slave_timeout 31536000</p><p>slave_net_timeout 60</p><p>thread_pool_idle_timeout 60</p><p>tokudb_last_lock_timeout</p><p>tokudb_lock_timeout 4000</p><p>tokudb_lock_timeout_debug 1</p><p>wait_timeout 7200</p><p>``</p><p>这也没什么问题。再多也不合理。</p><p>那可能就是本事mysql的驱动的问题了。</p><p>检查了下版本。再查了下，对应版本关系。</p><p><a href="https://dev.mysql.com/doc/connector-j/5.1/en/connector-j-versions.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/connector-j/5.1/en/connector-j-versions.html</a></p><p><a href="https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-versions.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-versions.html</a></p><p>官网瞄一眼</p><p>emmm，看到5.1的版本里有个Note</p><blockquote><p>MySQL Connector/J 8.0 is highly recommended for use with MySQL Server 8.0, 5.7, and 5.6. Please upgrade to MySQL Connector/J 8.0.</p></blockquote><p>那还说啥，升级到8.0咯</p><p>然后更新升级了上去，然后没问题了 …</p><p>Happy ending.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上线的项目遇到一个问题。异常信息如下：&lt;/p&gt;&lt;p&gt;``&lt;/p&gt;&lt;p&gt;SQLException: Could not retrieve transation read-only status server&lt;/p&gt;&lt;p&gt;……&lt;/p&gt;&lt;p&gt;Caused by: com.mysq
      
    
    </summary>
    
    
      <category term="技术栈" scheme="https://ghostsf.com/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="mysql" scheme="https://ghostsf.com/tags/mysql/"/>
    
      <category term="mybatis" scheme="https://ghostsf.com/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>nginx-proxy-read-responseheader-fail</title>
    <link href="https://ghostsf.com/nginx-proxy-read-responseheader-fail/"/>
    <id>https://ghostsf.com/nginx-proxy-read-responseheader-fail/</id>
    <published>2019-07-22T12:04:36.000Z</published>
    <updated>2020-04-01T09:51:38.587Z</updated>
    
    <content type="html"><![CDATA[<p>反向代理 recv() failed (104: Connection reset by peer) while reading response header from upstream错误</p><blockquote><p>原因就是请求的头文件过大导致502错误</p></blockquote><p><strong>解决方法就是提高头的缓存</strong></p><p>``<br>http {</p><pre><code>client_header_buffer_size 5m;location / {proxy_buffer_size 128k;proxy_busy_buffers_size 192k;proxy_buffers 4 192k;}</code></pre><p>}<br>``</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;反向代理 recv() failed (104: Connection reset by peer) while reading response header from upstream错误&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;原因就是请求的头文件过大导致502错误&lt;/p
      
    
    </summary>
    
    
      <category term="技术栈" scheme="https://ghostsf.com/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="nginx" scheme="https://ghostsf.com/tags/nginx/"/>
    
  </entry>
  
</feed>
