<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hi,ghostsf</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ghostsf.com/"/>
  <updated>2020-03-03T05:37:42.524Z</updated>
  <id>https://ghostsf.com/</id>
  
  <author>
    <name>ghostsf</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《江湖风云录之民谣》何教授2019 带歌词</title>
    <link href="https://ghostsf.com/qnmlgb/"/>
    <id>https://ghostsf.com/qnmlgb/</id>
    <published>2020-02-22T21:20:08.000Z</published>
    <updated>2020-03-03T05:37:42.524Z</updated>
    
    <content type="html"><![CDATA[<p>《江湖风云录之民谣》何教授2019.5.25 沈阳</p><blockquote><p>给大家配上了歌词，敬请欣赏 = =</p></blockquote><div id="player-qnmlgb"></div><script type="text/javascript">new DPlayer({container:document.getElementById("player-qnmlgb"),video:{url:"http://cdn.ghostsf.com/%E6%B1%9F%E6%B9%96%E9%A3%8E%E4%BA%91%E5%BD%95%E4%B9%8B%E6%B0%91%E8%B0%A3.mp4"}})</script><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《江湖风云录之民谣》何教授2019.5.25 沈阳&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;给大家配上了歌词，敬请欣赏 = =&lt;/p&gt;&lt;/blockquote&gt;&lt;div id=&quot;player-qnmlgb&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;new DPlayer({container:document.getElementById(&quot;player-qnmlgb&quot;),video:{url:&quot;http://cdn.ghostsf.com/%E6%B1%9F%E6%B9%96%E9%A3%8E%E4%BA%91%E5%BD%95%E4%B9%8B%E6%B0%91%E8%B0%A3.mp4&quot;}})&lt;/script&gt;
    
    </summary>
    
    
      <category term="闲言语" scheme="https://ghostsf.com/categories/%E9%97%B2%E8%A8%80%E8%AF%AD/"/>
    
      <category term="创作集" scheme="https://ghostsf.com/categories/%E9%97%B2%E8%A8%80%E8%AF%AD/%E5%88%9B%E4%BD%9C%E9%9B%86/"/>
    
    
      <category term="民谣" scheme="https://ghostsf.com/tags/%E6%B0%91%E8%B0%A3/"/>
    
  </entry>
  
  <entry>
    <title>逆行的伞</title>
    <link href="https://ghostsf.com/%E9%80%86%E8%A1%8C%E7%9A%84%E4%BC%9E/"/>
    <id>https://ghostsf.com/%E9%80%86%E8%A1%8C%E7%9A%84%E4%BC%9E/</id>
    <published>2020-02-14T10:53:01.000Z</published>
    <updated>2020-03-03T05:37:42.528Z</updated>
    
    <content type="html"><![CDATA[<h2 id="逆行的伞"><a href="#逆行的伞" class="headerlink" title="逆行的伞"></a>逆行的伞</h2><blockquote><p>写于2011年8月23日 14时</p></blockquote><p><img src="../images/post/%E9%80%86%E8%A1%8C%E7%9A%84%E4%BC%9E.jpeg" alt="逆行的伞"></p><p>独自<br>撑着一纸的孤单<br>任雨<br>在头顶轻叹<br>我在人群拥挤中逆行<br>渐渐丢了<br>手中握紧的伞<br>依稀<br>我看见水洼中倒映的脸<br>彷徨不安</p><hr><p>独自<br>撑着一纸的茫然<br>任雨<br>掉落无言的悲欢<br>我与人群擦肩而行<br>似乎想起<br>去年身旁的伞<br>如果<br>我期待那一瞬的相视无言<br>不问不管</p><hr><p>独自<br>撑着一纸的遗憾<br>任雨<br>溅湿双脚的蹒跚<br>人群在我的思绪中逆行<br>使我忘了<br>捡起丢落一旁的伞<br>于是<br>我祈祷前方背影的黯淡<br>顾首回盼</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;逆行的伞&quot;&gt;&lt;a href=&quot;#逆行的伞&quot; class=&quot;headerlink&quot; title=&quot;逆行的伞&quot;&gt;&lt;/a&gt;逆行的伞&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;写于2011年8月23日 14时&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;../i
      
    
    </summary>
    
    
      <category term="文艺斋" scheme="https://ghostsf.com/categories/%E6%96%87%E8%89%BA%E6%96%8B/"/>
    
    
      <category term="旧文字" scheme="https://ghostsf.com/tags/%E6%97%A7%E6%96%87%E5%AD%97/"/>
    
  </entry>
  
  <entry>
    <title>git-bundle</title>
    <link href="https://ghostsf.com/git-bundle/"/>
    <id>https://ghostsf.com/git-bundle/</id>
    <published>2020-01-16T09:53:06.000Z</published>
    <updated>2020-03-03T05:37:42.520Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Git-工具-打包-bundle"><a href="#Git-工具-打包-bundle" class="headerlink" title="Git 工具 - 打包 - bundle"></a>Git 工具 - 打包 - bundle</h2><p>虽然我们已经了解了网络传输 Git 数据的常用方法（如 HTTP，SSH 等），但还有另外一种不太常见却又十分有用的方式。</p><p>Git 可以将它的数据“打包”到一个文件中。 这在许多场景中都很有用。 有可能你的网络中断了，但你又希望将你的提交传给你的合作者们。 可能你不在办公网中并且出于安全考虑没有给你接入内网的权限。 可能你的无线、有线网卡坏掉了。 可能你现在没有共享服务器的权限，你又希望通过邮件将更新发送给别人，却不希望通过 format-patch 的方式传输 40 个提交。</p><p>这些情况下 git bundle 就会很有用。 bundle 命令会将 git push 命令所传输的所有内容打包成一个二进制文件，你可以将这个文件通过邮件或者闪存传给其他人，然后解包到其他的仓库中。</p><p>来看看一个简单的例子。 假设你有一个包含两个提交的仓库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git log  </span><br><span class="line">commit 9a466c572fe88b195efd356c3f2bbeccdb504102  </span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;  </span><br><span class="line">Date:   Wed Mar 10 07:34:10 2010 -0800  </span><br><span class="line">    second commit  </span><br><span class="line"></span><br><span class="line">commit b1ec3248f39900d2a406049d762aa68e9641be25  </span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;  </span><br><span class="line">Date:   Wed Mar 10 07:34:01 2010 -0800  </span><br><span class="line">    first commit</span><br></pre></td></tr></table></figure><p>如果你想把这个仓库发送给其他人但你没有其他仓库的权限，或者就是懒得新建一个仓库，你就可以用 git bundle create 命令来打包。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git bundle create repo.bundle HEAD master  </span><br><span class="line">Counting objects: 6, done.  </span><br><span class="line">Delta compression using up to 2 threads.    </span><br><span class="line">Compressing objects: 100% (2&#x2F;2), done.  </span><br><span class="line">Writing objects: 100% (6&#x2F;6), 441 bytes, done.  </span><br><span class="line">Total 6 (delta 0), reused 0 (delta 0)</span><br></pre></td></tr></table></figure><p>然后你就会有一个名为 repo.bundle 的文件，该文件包含了所有重建该仓库 master 分支所需的数据。 在使用 bundle 命令时，你需要列出所有你希望打包的引用或者提交的区间。 如果你希望这个仓库可以在别处被克隆，你应该像例子中那样增加一个 HEAD 引用。</p><p>你可以将这个 repo.bundle 文件通过邮件或者U盘传给别人。</p><p>另一方面，假设别人传给你一个 repo.bundle 文件并希望你在这个项目上工作。 你可以从这个二进制文件中克隆出一个目录，就像从一个 URL 克隆一样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git clone repo.bundle repo  </span><br><span class="line">Initialized empty Git repository in &#x2F;private&#x2F;tmp&#x2F;bundle&#x2F;repo&#x2F;.git&#x2F;  </span><br><span class="line">$ cd repo  </span><br><span class="line">$ git log --oneline  </span><br><span class="line">9a466c5 second commit </span><br><span class="line">b1ec324 first commit</span><br></pre></td></tr></table></figure><p>如果你在打包时没有包含 HEAD 引用，你还需要在命令后指定一个 -b master 或者其他被引入的分支，否则 Git 不知道应该检出哪一个分支。</p><p>现在假设你提交了 3 个修订，并且要用邮件或者U盘将新的提交放在一个包里传回去。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git log --oneline  </span><br><span class="line">71b84da last commit - second repo  </span><br><span class="line">c99cf5b fourth commit - second repo  </span><br><span class="line">7011d3d third commit - second repo  </span><br><span class="line">9a466c5 second commit  </span><br><span class="line">b1ec324 first commit</span><br></pre></td></tr></table></figure><p>首先我们需要确认我们希望被打包的提交区间。 和网络协议不太一样，网络协议会自动计算出所需传输的最小数据集，而我们需要手动计算。 当然你可以像上面那样将整个仓库打包，但最好仅仅打包变更的部分 —— 就是我们刚刚在本地做的 3 个提交。</p><p>为了实现这个目标，你需要计算出差别。 就像我们在 提交区间 介绍的，你有很多种方式去指明一个提交区间。 我们可以使用 origin/master..master 或者 master ^origin/master 之类的方法来获取那 3 个在我们的 master 分支而不在原始仓库中的提交。 你可以用 log 命令来测试。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git log --oneline master ^origin&#x2F;master </span><br><span class="line">71b84da last commit - second repo  </span><br><span class="line">c99cf5b fourth commit - second repo  </span><br><span class="line">7011d3d third commit - second repo</span><br></pre></td></tr></table></figure><p>这样就获取到我们希望被打包的提交列表，让我们将这些提交打包。 我们可以用 git bundle create 命令，加上我们想用的文件名，以及要打包的提交区间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git bundle create commits.bundle master ^9a466c5  </span><br><span class="line">Counting objects: 11, done.  </span><br><span class="line">Delta compression using up to 2 threads.  </span><br><span class="line">Compressing objects: 100% (3&#x2F;3), done.  </span><br><span class="line">Writing objects: 100% (9&#x2F;9), 775 bytes, done.  </span><br><span class="line">Total 9 (delta 0), reused 0 (delta 0)</span><br></pre></td></tr></table></figure><p>现在在我们的目录下会有一个 commits.bundle 文件。 如果我们把这个文件发送给我们的合作者，她可以将这个文件导入到原始的仓库中，即使在这期间已经有其他的工作提交到这个仓库中。</p><p>当她拿到这个包时，她可以在导入到仓库之前查看这个包里包含了什么内容。 bundle verify 命令可以检查这个文件是否是一个合法的 Git 包，是否拥有共同的祖先来导入。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git bundle verify ..&#x2F;commits.bundle  </span><br><span class="line">The bundle contains 1 ref  </span><br><span class="line">71b84daaf49abed142a373b6e5c59a22dc6560dc refs&#x2F;heads&#x2F;master  </span><br><span class="line">The bundle requires these 1 ref  </span><br><span class="line">9a466c572fe88b195efd356c3f2bbeccdb504102 second commit  </span><br><span class="line">..&#x2F;commits.bundle is okay</span><br></pre></td></tr></table></figure><p>如果打包工具仅仅把最后两个提交打包，而不是三个，原始的仓库是无法导入这个包的，因为这个包缺失了必要的提交记录。这时候 verify 的输出类似：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git bundle verify ..&#x2F;commits-bad.bundle  </span><br><span class="line">error: Repository lacks these prerequisite commits:   </span><br><span class="line">error: 7011d3d8fc200abe0ad561c011c3852a4b7bbe95 third commit - second repo</span><br></pre></td></tr></table></figure><p>而我们的第一个包是合法的，所以我们可以从这个包里提取出提交。 如果你想查看这边包里可以导入哪些分支，同样有一个命令可以列出这些顶端：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git bundle list-heads ..&#x2F;commits.bundle  </span><br><span class="line">71b84daaf49abed142a373b6e5c59a22dc6560dc refs&#x2F;heads&#x2F;master</span><br></pre></td></tr></table></figure><p>verify 子命令同样可以告诉你有哪些顶端。 该功能的目的是查看哪些是可以被拉入的，所以你可以使用 fetch 或者 pull 命令从包中导入提交。 这里我们要从包中取出 master 分支到我们仓库中的 other-master 分支：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch ..&#x2F;commits.bundle master:other-master  </span><br><span class="line">From ..&#x2F;commits.bundle  </span><br><span class="line"> * [new branch]      master     -&gt; other-master</span><br></pre></td></tr></table></figure><p>可以看到我们已经将提交导入到 other-master 分支，以及在这期间我们自己在 master 分支上的提交。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git log --oneline --decorate --graph --all  </span><br><span class="line">* 8255d41 (HEAD, master) third commit - first repo  </span><br><span class="line">| * 71b84da (other-master) last commit - second repo  </span><br><span class="line">| * c99cf5b fourth commit - second repo  </span><br><span class="line">| * 7011d3d third commit - second repo  </span><br><span class="line">|&#x2F;  </span><br><span class="line">* 9a466c5 second commit  </span><br><span class="line">* b1ec324 first commit</span><br></pre></td></tr></table></figure><p>因此，当你在没有合适的网络或者可共享仓库的情况下，git bundle 很适合用于共享或者网络类型的操作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Git-工具-打包-bundle&quot;&gt;&lt;a href=&quot;#Git-工具-打包-bundle&quot; class=&quot;headerlink&quot; title=&quot;Git 工具 - 打包 - bundle&quot;&gt;&lt;/a&gt;Git 工具 - 打包 - bundle&lt;/h2&gt;&lt;p&gt;虽然我们已经
      
    
    </summary>
    
    
      <category term="技术栈" scheme="https://ghostsf.com/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="git" scheme="https://ghostsf.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Vlog0x01 - IKBC F87 时光机 清洗记</title>
    <link href="https://ghostsf.com/vlog1/"/>
    <id>https://ghostsf.com/vlog1/</id>
    <published>2020-01-03T09:39:38.000Z</published>
    <updated>2020-03-03T05:37:42.524Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vlog0x01-IKBC-F87-时光机-清洗记"><a href="#Vlog0x01-IKBC-F87-时光机-清洗记" class="headerlink" title="Vlog0x01 - IKBC F87 时光机 清洗记"></a>Vlog0x01 - IKBC F87 时光机 清洗记</h2><p><a href="https://www.bilibili.com/video/av81643587/" target="_blank" rel="noopener">https://www.bilibili.com/video/av81643587/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Vlog0x01-IKBC-F87-时光机-清洗记&quot;&gt;&lt;a href=&quot;#Vlog0x01-IKBC-F87-时光机-清洗记&quot; class=&quot;headerlink&quot; title=&quot;Vlog0x01 - IKBC F87 时光机 清洗记&quot;&gt;&lt;/a&gt;Vlog0x01 
      
    
    </summary>
    
    
      <category term="创作集" scheme="https://ghostsf.com/categories/%E5%88%9B%E4%BD%9C%E9%9B%86/"/>
    
    
      <category term="vlog" scheme="https://ghostsf.com/tags/vlog/"/>
    
  </entry>
  
  <entry>
    <title>未知生物圣诞游行</title>
    <link href="https://ghostsf.com/christmas/"/>
    <id>https://ghostsf.com/christmas/</id>
    <published>2019-12-26T13:49:41.000Z</published>
    <updated>2020-03-03T05:37:42.520Z</updated>
    
    <content type="html"><![CDATA[<h2 id="未知生物圣诞游行-直通"><a href="#未知生物圣诞游行-直通" class="headerlink" title="未知生物圣诞游行 直通"></a><a href="https://www.bilibili.com/video/av80718385/" target="_blank" rel="noopener">未知生物圣诞游行 直通</a></h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;未知生物圣诞游行-直通&quot;&gt;&lt;a href=&quot;#未知生物圣诞游行-直通&quot; class=&quot;headerlink&quot; title=&quot;未知生物圣诞游行 直通&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.bilibili.com/video/av80718385/&quot; 
      
    
    </summary>
    
    
      <category term="创作集" scheme="https://ghostsf.com/categories/%E5%88%9B%E4%BD%9C%E9%9B%86/"/>
    
    
      <category term="圣诞节" scheme="https://ghostsf.com/tags/%E5%9C%A3%E8%AF%9E%E8%8A%82/"/>
    
      <category term="vlog" scheme="https://ghostsf.com/tags/vlog/"/>
    
  </entry>
  
  <entry>
    <title>修改git历史提交信息</title>
    <link href="https://ghostsf.com/git-commit-change/"/>
    <id>https://ghostsf.com/git-commit-change/</id>
    <published>2019-12-26T10:33:53.000Z</published>
    <updated>2020-03-03T05:37:42.520Z</updated>
    
    <content type="html"><![CDATA[<p>修复 git 历史提交信息<br>To change the name and/or email address recorded in existing commits, you must rewrite the entire history of your Git repository.</p><p>为了修改 commit 的作者邮箱地址，你必须重写整个 git 仓库历史</p><p>Warning: This action is destructive to your repository’s history. If you’re collaborating on a repository with others, it’s considered bad practice to rewrite published history. You should only do this in an emergency.</p><p>警告： 这个操作会破坏你的仓库历史， 如果你和别人在协同开发这个仓库，重写已发布的历史记录是一个不好的操作。建议只在紧急情况操作</p><p>操作步骤：</p><a id="more"></a><p>打开 bash</p><p>Create a fresh, bare clone of your repository: （新建一个全新的仓库信息：)</p><pre><code>git clone --bare https://github.com/user/repo.gitcd repo.git</code></pre><p>Copy and paste the script, replacing the following variables based on the information you gathered: (在终端复制并粘贴以下脚本，并将以下的变量修改为你需要的)</p><p><strong>OLD_EMAIL</strong></p><p><strong>CORRECT_NAME</strong></p><p><strong>CORRECT_EMAIL</strong></p><p>脚本信息：</p><p><a href="https://gist.github.com/ghostsf/de39ebde3a50b0fcaf4f3de172940969" target="_blank" rel="noopener">git-commit-change.sh</a></p><p>Press Enter to run the script.（按下 enter 键来运行这个脚本</p><p>Review the new Git history for errors.(校对新的 git 仓库历史）</p><p>Push the corrected history to GitHub:（将修改后的仓库历史推到远程）</p><p>git push –force –tags origin ‘refs/heads/*’<br>Clean up the temporary clone: (删除这个仓库)</p><p>cd ..<br>rm -rf repo.git</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;修复 git 历史提交信息&lt;br&gt;To change the name and/or email address recorded in existing commits, you must rewrite the entire history of your Git repository.&lt;/p&gt;&lt;p&gt;为了修改 commit 的作者邮箱地址，你必须重写整个 git 仓库历史&lt;/p&gt;&lt;p&gt;Warning: This action is destructive to your repository’s history. If you’re collaborating on a repository with others, it’s considered bad practice to rewrite published history. You should only do this in an emergency.&lt;/p&gt;&lt;p&gt;警告： 这个操作会破坏你的仓库历史， 如果你和别人在协同开发这个仓库，重写已发布的历史记录是一个不好的操作。建议只在紧急情况操作&lt;/p&gt;&lt;p&gt;操作步骤：&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术栈" scheme="https://ghostsf.com/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="git" scheme="https://ghostsf.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>tar命令参数</title>
    <link href="https://ghostsf.com/tar/"/>
    <id>https://ghostsf.com/tar/</id>
    <published>2019-12-24T17:07:19.000Z</published>
    <updated>2020-03-03T05:37:42.524Z</updated>
    
    <content type="html"><![CDATA[<h3 id="tar命令参数说明"><a href="#tar命令参数说明" class="headerlink" title="tar命令参数说明"></a>tar命令参数说明</h3><p>-c : 建立一个打包文件；</p><p>-x ：解开一个打包文件；</p><p>-t ：查看 tar包里面的文件；</p><p>（特别注意，在选择参数时，c/x/t仅能存在一个，不可同时存在，因为不可能同时压缩与解压缩。）</p><p>-z ：打包后用gzip压缩，生成.tar.gz文件；</p><p>-j ：打包后用zip2压缩，生成.tar.bz2文件；</p><p>-v ：压缩的过程中显示文件；</p><p>-f ：使用文件名，请留意，在f之后要立即接文件名，不要再加其它参数；</p><p>-p ：保持原文件的属性；</p><p>-P ：使用绝对路径来压缩；</p><p>-N ：设定日期(yyyy/mm/dd)，比后面接的日期还要新的文件才会被打包进新建的文件中；</p><p>–exclude FILE：在打包的过程中，不要将FILE打包。</p><blockquote><ul><li><ul><li>可能我用得少，老记不住 这里初步整理下</li></ul></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;tar命令参数说明&quot;&gt;&lt;a href=&quot;#tar命令参数说明&quot; class=&quot;headerlink&quot; title=&quot;tar命令参数说明&quot;&gt;&lt;/a&gt;tar命令参数说明&lt;/h3&gt;&lt;p&gt;-c : 建立一个打包文件；&lt;/p&gt;&lt;p&gt;-x ：解开一个打包文件；&lt;/p&gt;&lt;p&gt;-
      
    
    </summary>
    
    
      <category term="技术栈" scheme="https://ghostsf.com/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="linux" scheme="https://ghostsf.com/tags/linux/"/>
    
      <category term="tar" scheme="https://ghostsf.com/tags/tar/"/>
    
  </entry>
  
  <entry>
    <title>自建maven私有仓库实践</title>
    <link href="https://ghostsf.com/nexus/"/>
    <id>https://ghostsf.com/nexus/</id>
    <published>2019-12-24T15:20:35.000Z</published>
    <updated>2020-03-03T05:37:42.524Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>记录一次自建maven私有仓库的过程 = = ， 其实是为了凑个更新</p></blockquote><h2 id="0x01-仓库管理软件"><a href="#0x01-仓库管理软件" class="headerlink" title="0x01 仓库管理软件"></a>0x01 仓库管理软件</h2><p>目前比较流行的有Apache基金会的 Archiva，JFrog 的 Artifactory ，Sonatypec 的 Nexus</p><h2 id="0x02-环境"><a href="#0x02-环境" class="headerlink" title="0x02 环境"></a>0x02 环境</h2><p>要求 Java 8 Runtime Environment或者以上</p><h2 id="0x03-下载运行Nexus"><a href="#0x03-下载运行Nexus" class="headerlink" title="0x03 下载运行Nexus"></a>0x03 下载运行Nexus</h2><p>去 <a href="https://help.sonatype.com/repomanager3/download/download-archives---repository-manager-3" target="_blank" rel="noopener">官网</a> 根据你的操作系统选择下载</p><p>进入bin目录，运行即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Unix &amp; OS X</span><br><span class="line">.&#x2F;nexus run</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Windows  </span><br><span class="line">nexus.exe &#x2F;run</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nexus run 前台运行，可以实时查看运行log</span><br><span class="line"></span><br><span class="line">nexus start 后台运行</span><br><span class="line"></span><br><span class="line">nexus stop 关闭</span><br></pre></td></tr></table></figure><p>默认端口: 8081</p><p>默认的管理员账号密码为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">username：admin</span><br><span class="line">password：admin123</span><br></pre></td></tr></table></figure><p>nexus3 安全性提高了些，admin的密码在<code>~/sonatype-work/nexus3/admin.password</code>文件里</p><h2 id="0x04-配置"><a href="#0x04-配置" class="headerlink" title="0x04 配置"></a>0x04 配置</h2><p>配置文件地址</p><p><code>./etc/nexus-default.properties</code> 可配置端口等参数</p><p><code>./bin/nexus.vmoptions</code> 可配置数据存储的目录以及内存参数等</p><h2 id="0x05-其他配置"><a href="#0x05-其他配置" class="headerlink" title="0x05 其他配置"></a>0x05 其他配置</h2><p><strong>服务自启</strong></p><p>在/etc/systemd/system/下创建nexus.service文件</p><p><code>vi /etc/systemd/system/nexus.service</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line"></span><br><span class="line">Description&#x3D;nexus service</span><br><span class="line"></span><br><span class="line">After&#x3D;network.target</span><br><span class="line">  </span><br><span class="line">[Service]</span><br><span class="line"></span><br><span class="line">Type&#x3D;forking</span><br><span class="line"></span><br><span class="line">LimitNOFILE&#x3D;65536</span><br><span class="line"></span><br><span class="line">ExecStart&#x3D;~&#x2F;bin&#x2F;nexus start</span><br><span class="line"></span><br><span class="line">ExecStop&#x3D;~&#x2F;bin&#x2F;nexus stop</span><br><span class="line"></span><br><span class="line">User&#x3D;nexus</span><br><span class="line"></span><br><span class="line">Restart&#x3D;on-abort</span><br><span class="line">  </span><br><span class="line">[Install]</span><br><span class="line"></span><br><span class="line">WantedBy&#x3D;multi-user.target</span><br></pre></td></tr></table></figure><p><strong>systemctl命令</strong></p><p>更新systemctl</p><p><code>sudo systemctl daemon-reload</code></p><p>设置开机启动</p><p><code>sudo systemctl enable nexus.service</code></p><p>启动nexus服务</p><p><code>sudo systemctl start nexus.service</code></p><p>查看nexus服务状态</p><p><code>sudo systemctl status nexus.service</code></p><p>查看日志</p><p><code>tail -f ~/sonatype-work/nexus3/log/nexus.log</code></p><h2 id="0x06-使用配置"><a href="#0x06-使用配置" class="headerlink" title="0x06 使用配置"></a>0x06 使用配置</h2><p><strong>maven</strong></p><p><strong>maven发布包</strong></p><p>pom.xml 参考</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;distributionManagement&gt;</span><br><span class="line"></span><br><span class="line">    &lt;repository&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;id&gt;nexus-releases&lt;&#x2F;id&gt;</span><br><span class="line">        </span><br><span class="line">        &lt;name&gt;private-nexus-library-releases&lt;&#x2F;name&gt;</span><br><span class="line">        </span><br><span class="line">        &lt;url&gt;http:&#x2F;&#x2F;&#123;host&#125;&#x2F;repository&#x2F;maven-releases&#x2F;&lt;&#x2F;url&gt;</span><br><span class="line">        </span><br><span class="line">    &lt;&#x2F;repository&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;snapshotRepository&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;id&gt;nexus-snapshots&lt;&#x2F;id&gt;</span><br><span class="line">        </span><br><span class="line">        &lt;name&gt;private-nexus-library-snapshots&lt;&#x2F;name&gt;</span><br><span class="line">        </span><br><span class="line">        &lt;url&gt;http:&#x2F;&#x2F;&#123;host&#125;&#x2F;repository&#x2F;maven-snapshots&#x2F;&lt;&#x2F;url&gt;</span><br><span class="line">        </span><br><span class="line">    &lt;&#x2F;snapshotRepository&gt;</span><br><span class="line">&lt;&#x2F;distributionManagement&gt;</span><br></pre></td></tr></table></figure><p>maven settings.xml 参考</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;servers&gt;</span><br><span class="line"></span><br><span class="line">&lt;server&gt;</span><br><span class="line"></span><br><span class="line">  &lt;id&gt;nexus-releases&lt;&#x2F;id&gt;</span><br><span class="line"></span><br><span class="line">  &lt;username&gt;username&lt;&#x2F;username&gt;</span><br><span class="line"></span><br><span class="line">  &lt;password&gt;password&lt;&#x2F;password&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;server&gt;</span><br><span class="line"></span><br><span class="line">&lt;server&gt;</span><br><span class="line"></span><br><span class="line">  &lt;id&gt;nexus-snapshots&lt;&#x2F;id&gt;</span><br><span class="line"></span><br><span class="line">  &lt;username&gt;username&lt;&#x2F;username&gt;</span><br><span class="line"></span><br><span class="line">  &lt;password&gt;password&lt;&#x2F;password&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;server&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;servers&gt;</span><br></pre></td></tr></table></figure><p>*<em>maven使用 *</em></p><p>mirrors add</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-private<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus private<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://&#123;host&#125;/repository/maven-public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure><p>ps：若设置了不允许匿名用户访问<br>则使用远程仓库的时候需要使用鉴权URL</p><p>eg:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-private<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus private<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://&#123;username&#125;:&#123;password&#125;@&#123;host&#125;/repository/maven-public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure><p>// todo 还有很多要整理 有空出个相关专题文章吧</p><h2 id="0x07-注意事项"><a href="#0x07-注意事项" class="headerlink" title="0x07 注意事项"></a>0x07 注意事项</h2><p><strong>修改运行用户</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">WARNING: ************************************************************</span><br><span class="line"></span><br><span class="line">WARNING: Detected execution as "root" user.  This is NOT recommended!</span><br><span class="line"></span><br><span class="line">WARNING: ************************************************************</span><br></pre></td></tr></table></figure><p>创建一个单独的用户进行运行，安全一些</p><p><code>adduser nexus</code></p><p><code>passwd nexus</code></p><p>然后修改nexus为运行用户</p><p><code>vi ./bin/nexus.rc</code></p><p>取消注释，并修改为如下内容</p><p><code>run_as_user=&quot;nexus&quot;</code></p><p>修改nexus3文件的所有者</p><p><code>chown -R nexus:nexus ~/nexus3/</code></p><p><strong>备份迁移</strong></p><p>默认配置 nexus的数据都在此目录下</p><p><code>sonatype-work</code></p><p>该目录可在<code>./bin/nexus.vmoptions</code>自定义配置</p><p>需要备份迁移，只要打包这个目录即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;记录一次自建maven私有仓库的过程 = = ， 其实是为了凑个更新&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&quot;0x01-仓库管理软件&quot;&gt;&lt;a href=&quot;#0x01-仓库管理软件&quot; class=&quot;headerlink&quot; title=&quot;0x01
      
    
    </summary>
    
    
      <category term="技术栈" scheme="https://ghostsf.com/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="maven" scheme="https://ghostsf.com/tags/maven/"/>
    
      <category term="nexus" scheme="https://ghostsf.com/tags/nexus/"/>
    
      <category term="私有仓库" scheme="https://ghostsf.com/tags/%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>免费BT离线下载收集</title>
    <link href="https://ghostsf.com/bt/"/>
    <id>https://ghostsf.com/bt/</id>
    <published>2019-12-23T11:41:40.000Z</published>
    <updated>2020-03-03T05:37:42.520Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th align="left">名称</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left">OffCloud</td><td align="left">单文件无限制，总空间 100G</td></tr><tr><td align="left">Streamza</td><td align="left">单文件 1G 限制，队列 1，无法下载回本地，可在线</td></tr><tr><td align="left">BytesLoader</td><td align="left">单文件无限制，队列 2</td></tr><tr><td align="left">FURK</td><td align="left">单文件 2G 限制，队列 2，可在线</td></tr><tr><td align="left">DirectTorrents</td><td align="left">总文件 10G 限制 队列 3</td></tr><tr><td align="left">Zbigz</td><td align="left">单文件 1G 限制，队列 2，限速 150K，7 天保存</td></tr><tr><td align="left">FileStream</td><td align="left">单文件 1G 限制，队列 2，3 天保存</td></tr><tr><td align="left">FilesLoop</td><td align="left">单文件 1G 限制，队列 1</td></tr><tr><td align="left">BitPort</td><td align="left">单文件 1G 限制，队列 1</td></tr><tr><td align="left">Seedr</td><td align="left">单文件 2G 限制，队列 1</td></tr><tr><td align="left">ByteBX</td><td align="left">单文件 100M 限制，队列不限，总空间 2.5G</td></tr><tr><td align="left">TorrentSafe</td><td align="left">单文件无限制，月队列 3，总空间 10G</td></tr><tr><td align="left">2Giga</td><td align="left">单文件 2G 限制，队列 1</td></tr><tr><td align="left">SonicSeedbox</td><td align="left">单文件无限制，天队列 2，总空间 4G</td></tr><tr><td align="left">HiperDown</td><td align="left">单文件无限制，队列 2，总空间 5G</td></tr></tbody></table><blockquote><p>版权声明：转载自 <a href="https://imoe.xyz/post/120.html" target="_blank" rel="noopener">《免费BT离线下载服务汇总》</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th align=&quot;left&quot;&gt;名称&lt;/th&gt;&lt;th align=&quot;left&quot;&gt;介绍&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;OffCloud&lt;/td&gt;&lt;td align=&quot;left&quot;&gt;单文件
      
    
    </summary>
    
    
      <category term="分享境" scheme="https://ghostsf.com/categories/%E5%88%86%E4%BA%AB%E5%A2%83/"/>
    
    
      <category term="BT" scheme="https://ghostsf.com/tags/BT/"/>
    
      <category term="免费" scheme="https://ghostsf.com/tags/%E5%85%8D%E8%B4%B9/"/>
    
  </entry>
  
  <entry>
    <title>群辉玩物下载套件</title>
    <link href="https://ghostsf.com/dsm-xunlei/"/>
    <id>https://ghostsf.com/dsm-xunlei/</id>
    <published>2019-12-06T14:37:43.000Z</published>
    <updated>2020-03-03T05:37:42.520Z</updated>
    
    <content type="html"><![CDATA[<p>正愁黑群辉没有一个给力的下载器的时候。（Transmission 、 docker+aria2 都不是很理想）</p><blockquote><p>9月20日，NAS大厂群晖科技在上海举办了Synology 2020年度大会，会上宣布与迅雷合作，推出“玩物下载”套件。</p></blockquote><p>那么就美滋滋了。</p><blockquote><p>在群晖NAS里，安装玩物套件并且绑定迅雷帐号后，可以直接将下载的多媒体文件存储在NAS里。出门在外时，远程访问DSM操作下载，回到家即可享受大片。</p></blockquote><p>迫不及待地，安装，试用了。</p><p>emm，真香，基本都是满速。有的比pc上的迅雷都要快很多。</p><p>界面很简单，简单得没什么好操作的 = =</p><p><img src="/images/post/dsm-xunlei.png" alt="玩物下载"></p><p>瞄一眼这速度~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;正愁黑群辉没有一个给力的下载器的时候。（Transmission 、 docker+aria2 都不是很理想）&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;9月20日，NAS大厂群晖科技在上海举办了Synology 2020年度大会，会上宣布与迅雷合作，推出“玩物下载”套件。&lt;/p
      
    
    </summary>
    
    
      <category term="分享境" scheme="https://ghostsf.com/categories/%E5%88%86%E4%BA%AB%E5%A2%83/"/>
    
    
      <category term="群辉" scheme="https://ghostsf.com/tags/%E7%BE%A4%E8%BE%89/"/>
    
  </entry>
  
  <entry>
    <title>安利一款游戏《战双帕弥什》</title>
    <link href="https://ghostsf.com/pns-kurogame/"/>
    <id>https://ghostsf.com/pns-kurogame/</id>
    <published>2019-12-06T14:00:09.000Z</published>
    <updated>2020-03-03T05:37:42.524Z</updated>
    
    <content type="html"><![CDATA[<div id="player-pns"></div><script type="text/javascript">new DPlayer({container:document.getElementById("player-pns"),video:{url:"http://cdnstatic.kurogame.com/pns/2.0/images/video1.mp4"}})</script><p>《战双帕弥什》是广州库洛科技有限公司研发的一款末世科幻题材的3D动作手游。你将化身指挥官，带领人类最后的希望——仿生人形「构造体」，共同对抗被「帕弥什」病毒感染的机械大军。运用你的判断力，灵活地滑动指尖，触发不同的技能招式，在世界的终焉打出华丽一战吧！</p><a id="more"></a><h2 id="世界观"><a href="#世界观" class="headerlink" title="世界观"></a>世界观</h2><h3 id="资料001"><a href="#资料001" class="headerlink" title="资料001"></a>资料001</h3><div id="player-1"></div><script type="text/javascript">new DPlayer({container:document.getElementById("player-1"),video:{url:"http://video.zspns.kurogame.com/hd/2f317626420f4cf99f6d8ec4c2b17568.mp4",pic:"http://cdnimg02.kurogame.com/M00/14/82/ChpCl13nYT2ELg1_AAAAAKugTRY122.jpg"}})</script><h3 id="资料002"><a href="#资料002" class="headerlink" title="资料002"></a>资料002</h3><div id="player-2"></div><script type="text/javascript">new DPlayer({container:document.getElementById("player-2"),video:{url:"http://video.zspns.kurogame.com/hd/2f317626420f4cf99f6d8ec4c2b17568.mp4",pic:"http://cdnimg01.kurogame.com/M00/14/82/ChpCl13nao2EPxARAAAAABXzQNo687.jpg"}})</script><h2 id="壁纸欣赏"><a href="#壁纸欣赏" class="headerlink" title="壁纸欣赏"></a>壁纸欣赏</h2><h3 id="丽芙-纯白之花"><a href="#丽芙-纯白之花" class="headerlink" title="丽芙-纯白之花"></a>丽芙-纯白之花</h3><p><img src="/images/post/pns-5.jpg" alt="丽芙-纯白之花"></p><h3 id="比安卡-严霜凛雪"><a href="#比安卡-严霜凛雪" class="headerlink" title="比安卡-严霜凛雪"></a>比安卡-严霜凛雪</h3><p><img src="/images/post/pns-4.jpg" alt="比安卡-严霜凛雪"></p><h3 id="卡列尼娜"><a href="#卡列尼娜" class="headerlink" title="卡列尼娜"></a>卡列尼娜</h3><p><img src="/images/post/pns-1.jpg" alt="卡列尼娜"></p><h3 id="露西亚"><a href="#露西亚" class="headerlink" title="露西亚"></a>露西亚</h3><p><img src="/images/post/pns-2.jpg" alt="露西亚"></p><h3 id="里"><a href="#里" class="headerlink" title="里"></a>里</h3><p><img src="/images/post/pns-3.jpg" alt="里"></p><h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p><a href="https://wiki.biligame.com/zspms/" target="_blank" rel="noopener">直达wiki</a></p><h3 id="上app-store主推了-191209"><a href="#上app-store主推了-191209" class="headerlink" title="上app store主推了 191209"></a>上app store主推了 191209</h3><p><a href="https://apps.apple.com/cn/story/id1484805266" target="_blank" rel="noopener">appstore主推</a></p>]]></content>
    
    <summary type="html">
    
      &lt;div id=&quot;player-pns&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;new DPlayer({container:document.getElementById(&quot;player-pns&quot;),video:{url:&quot;http://cdnstatic.kurogame.com/pns/2.0/images/video1.mp4&quot;}})&lt;/script&gt;&lt;p&gt;《战双帕弥什》是广州库洛科技有限公司研发的一款末世科幻题材的3D动作手游。你将化身指挥官，带领人类最后的希望——仿生人形「构造体」，共同对抗被「帕弥什」病毒感染的机械大军。运用你的判断力，灵活地滑动指尖，触发不同的技能招式，在世界的终焉打出华丽一战吧！&lt;/p&gt;
    
    </summary>
    
    
      <category term="分享境" scheme="https://ghostsf.com/categories/%E5%88%86%E4%BA%AB%E5%A2%83/"/>
    
    
      <category term="游戏" scheme="https://ghostsf.com/tags/%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>Jrebel for android</title>
    <link href="https://ghostsf.com/jrebel-android/"/>
    <id>https://ghostsf.com/jrebel-android/</id>
    <published>2019-11-28T18:07:55.000Z</published>
    <updated>2020-03-03T05:37:42.524Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h3><blockquote><p>Plugins -&gt; Manage Plugin Repositories -&gt; add</p></blockquote><p><code>http://dl.zeroturnaround.com/jrebel-android/plugins/ide-studio/updatePlugins.xml</code></p><h3 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h3><blockquote><p>Install <code>JRebel for Android</code></p></blockquote><h3 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h3><blockquote><p>Activation</p></blockquote><p><code>Group URL:http://idea.lanyus.com/UUID</code></p><p><code>Email:your email</code></p><h3 id="0x04"><a href="#0x04" class="headerlink" title="0x04"></a>0x04</h3><blockquote><p>Run or debug by Jrebel</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;0x01&quot;&gt;&lt;a href=&quot;#0x01&quot; class=&quot;headerlink&quot; title=&quot;0x01&quot;&gt;&lt;/a&gt;0x01&lt;/h3&gt;&lt;blockquote&gt;&lt;p&gt;Plugins -&amp;gt; Manage Plugin Repositories -&amp;gt; add
      
    
    </summary>
    
    
      <category term="技术栈" scheme="https://ghostsf.com/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="AndroidStudio" scheme="https://ghostsf.com/tags/AndroidStudio/"/>
    
  </entry>
  
  <entry>
    <title>善用 Android Studio 的异动管理功能</title>
    <link href="https://ghostsf.com/as-move/"/>
    <id>https://ghostsf.com/as-move/</id>
    <published>2019-11-21T14:38:15.000Z</published>
    <updated>2020-03-03T05:37:42.520Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>看到一篇难得的关于Android Studio 的异动管理功能的说明文章，姑且转载分享之<br>图片还没整理好 太懒了 后续再慢慢整理 完善吧</p></blockquote><p>身为一个开发人员，每天的工作就是在不断地异动 Source Code 中度过。增加新的、修改旧的、删掉不要的，而每一个异动都会对应到特定的目的，像是为了新的需求、修改 Bug、重构程式等等。</p><p>很多时候，异动的目的在工作的过程中是混在一起的，例如开发新功能的同时，也有可能在修正之前的问题。在自己的工作环境中，这些异动混在一起通常都不会有什么问题产生。只不过这些工作的成果终究是要交付出去的，而问题总在于这些目的却不一定是在同一个时间点被交付。如果所有的异动都混在一起，要隔离出需要交付的部份，势必要花费一番工夫才能办得到。</p><p>而这样的工作要靠人工来逐个 Block、逐个 File 来分辨识，不但耗时，同时也极有可能出现疏漏。因为一个修改就有可能牵涉到十几个 Files，再加上 IDE 自动产生或管理的加一加可能就有成百上千之数。自己经手的异动都不一定能精确的掌握，更何况是数量在数倍、完全不是自己产生的内容。</p><p>人工应付不来，就得要靠工具的辅助。就如同在“ <a href="https://www.jianshu.com/p/50ab4a02c19f" target="_blank" rel="noopener">如何写好程序</a> ”一文中提到，善用工具是写好程序的功课之一。以开发 Android 时所使用的 Android Studio 来说，虽然是由 IntelliJ IDEA Community 版本进化而来，但不代表功能上就很阳春。针对本文提到的问题，其实有内建了相当方便的功能，可以协助开发者解决这类工作上的问题。</p><h2 id="Android-Studio-提供的异动管理功能"><a href="#Android-Studio-提供的异动管理功能" class="headerlink" title="Android Studio 提供的异动管理功能"></a>Android Studio 提供的异动管理功能</h2><h3 id="Changelist"><a href="#Changelist" class="headerlink" title="Changelist"></a>Changelist</h3><p>这是一个以 File 为单位，把异动内容给分门别类的功能。透过这个功能，可以把修改过的 File 进行分组。当有异动内容需要被交付时，可以直接以分好的组别为单位交付。像是要进行 Commit 时，则可以指定特定的 Changelist 来 Commit，不在分组内的 Files 则不会受影响。</p><p>要使用这个功能可以先进入 Version Control Tool Window，Menu 的位置在【View -&gt; Tool Windows -&gt; Version Control】。开启之后可以看见如下图示的内容：</p><p>在 Local Changes 的 Tab 中，可以看到有一个 <code>Default</code> 的字样，这就是 Android Studio 预先产生好的 Changelist。如果没有特别指定，所有被异动的 Files 都会被归在这个 Changelist 之下。在操作上可以使用 Tool Window 中左方的按钮来新增一个 Changelist，新增时可设定此 Changelist 为 Active，代表之后所有还没被异动的 File，在异动后都会被归到这个 Changelist 之下。</p><p>要在 Changelist 之间移动 File 也非常地直觉，可以使用拖拉项目的方式，或是在项目上按下滑鼠右键选择【Move to Another Changelist…】即可。</p><p>当要进行 Commit 时，就可以在如下的“Commit Changes”画面中，最上方的下拉清单选择对应的 Changelist。</p><p>选择不同的 Changelist 时，Changelist 的名称会预设成为 Commit Message 的内容。</p><p>由于 Changelist 是以 File 为单位，所以会有一个限制是同一个 File 不能同时归属于二个 Changelist。一旦编辑了不在 Active Changelist 中的 File，Android Studio 就会出现以下的警告：</p><p>可以看见 Tab 上的文件名变成了红色，这是 Android Studio 遇到异动冲突预设的反应，这部份可以透过点选画面中最右方的按钮来调整。</p><p>这时如果只是忘了切换 Active Changelist，可以选择【Ignore】或是【Switch changelist】。但若真的是二个不同的修改项目都异动到同一个 File，那就得选择一个适当的策略。</p><p>当修改的内容不会有交互的影响，也就是说二个修改项目的结果可以共存在同一个 File 之中，则可以选择【Move changes】把 File 移到最先要被 Commit 的 Changelist 中。</p><p>反之，修改的内容是互斥的时候，就要先保留其中一个版本、还原回修改前的状态后，再开始另一个项目的修改。这个方式在 Android Studio 中也有提供了对应的功能来达成，在这篇文章的稍后会提到。</p><p>Changelist 在使用的情境上，还可以用来区隔一定会修改，但却没有要 Commit 的 File。例如有一些程序运行时需要的配置文件，内容中记录的是 Production 的参数，在开发时就必须要进行修改才能做调试。这时就可以预先新增好一个专用的 Changelist，把这类的 Files 在修改之后归进去。未来在 Commit 时才不致一时疏忽，把开发环境的设定参数给 Commit，造成后续生成上的问题。</p><h3 id="Label"><a href="#Label" class="headerlink" title="Label"></a>Label</h3><p>Label 主要是作用在【VCS -&gt; Local History -&gt; Show History】的 Window 上，如下图所示：</p><p>在 Window 的左侧，可以看到第一个和第二个 History 项目中间，夹了一个 Sample Label 的文字，这个文字是使用【VCS -&gt; Local History -&gt; Put Label…】功能放上去的。</p><p>透过这个功能，可以在进行一些实验性的调整之前，先标定好目前 Source Code 状态。当调整不如预期时，就可以不用花精神去回想做了哪些的修改，再一一去做回复。有了 Label 就可以在 History 的清单中找到所标定的 Source Code 状态，使用【Revert】的功能，直接回到调整前的状态，相当地省事又有效率。</p><h3 id="Shelf"><a href="#Shelf" class="headerlink" title="Shelf"></a>Shelf</h3><p>字面上的意义就是架子，是一个用来摆放文件夹的架子。而文件夹则是前面所提到的 Changelist 的快照，所以当 Changelist 发生冲突时，就可以利用 Shelf 把 Changelist 当下的状态保留起来，等到冲突的情况解决了之后，再把原本异动的内容还原回来。</p><p>要把 Changelist 放到架子上，可以从 Menu 中选择【VCS -&gt; Shelve Changes…】。</p><p>可以由上图看到，画面和 Commit 差不多。完成之后，会在 Version Control Tool Window 中多出一个 Shelf 的 Tab，同时被 Shelve 的 Files 会回到异动前的状态。在 Shelf 的 Tab 上，可以管理 Shelve 过的项目，像是 Unshelve、Rename、Delete。</p><p>在 Unshelve 的过程中，如果没有出现内容冲突，则会自动套用 Shelf 中保留的异动状态。如果内容出现冲突时，则会显示以下的 Window，要求决定所需套用的版本：</p><p>Shelf 除了应用在工作项目的切换之外，如果所开发的 Project 有多个 Branch，在 Branch 还没有相互 Merge 之前，也可以使用 Shelf 来转移、把异动过程套用在不同的 Branch 上。这一点在异动的 Files 数量庞大时，就可以显现出效率上差别，一个批次就可以完成工作，不用再一个个 File 来比对，并且担心是否有异动的内容遗漏了。</p><h3 id="Patch"><a href="#Patch" class="headerlink" title="Patch"></a>Patch</h3><p>Patch 可以算是 Shelf 的外带版本，外带去哪？就是把异动的内容带出 Android Studio 的环境之外。使用 Menu 中【VCS -&gt; Create Patch…】的功能，可以把原本要新增到 Shelf 的项目，改为产生一个实体的 File。操作的画面和 Shelve Changes 一模一样，只是在按下 Window 上【Create Patch…】的按钮后，会出现以下的画面，以便指定 File 储存的位置。</p><p>基本上 Shelf 的项目和 Patch 可以互换，在 Tool Window 中 Shelf 的项目上可以触发 Create Patch 的动作，让 Shelf 的项目转成 Patch。反之，也可以在 Shelf 的 Tab 上 Import Patches 成为 Shelf 的项目。在产生 Shelf 项目和 Patch 时，还有一点最大的差异是 Patch 产生之后，并不会将内容回复到异动之前，而是维持修改后的状态。</p><p>从 Menu 中选择【VCS -&gt; Apply Patch…】后，可以把 Patch 的内容套用回目前的工作环境中，套用的过程和 Shelf 差不多，遇到内容冲突时也同样会出现相同的画面，来决定要选用的版本。</p><p>在应用上，Shelf 的项目能做的 Patch 都能做，除此之外 Patch 还可以用来在不同的 Android Studio 环境之间移转。可以用来将工作的状态由公司的环境中移至家中的环境，以便在离开公司之后仍可接续未完成的部份。或者是可以把 Patch 交给不同的开发人员，用来进行协同合作、Review Code 等工作。</p><p>和版本控管工具的比较<br>如果在开发时使用 Git 做为版本控管的工具，其实以上的功能 Git 大多都可以做到。Android Studio 则是在原有的版本控管机制之外，提供不同的选项，对于不熟悉版本控管工具的人来说有莫大的帮助。而对于用惯了原本工具的人来说，要怎么使用还是得看每个人的习惯、对工具的喜好程度。只不过在面对不同的情况之下，多学会一种工具的使用，在应对的策略上也能产生更多的弹性。</p><p>作者：<em>WZ</em></p><p>链接：<a href="https://www.jianshu.com/p/f66e3ad097ad" target="_blank" rel="noopener">https://www.jianshu.com/p/f66e3ad097ad</a></p><p>来源：简书</p><p>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;看到一篇难得的关于Android Studio 的异动管理功能的说明文章，姑且转载分享之&lt;br&gt;图片还没整理好 太懒了 后续再慢慢整理 完善吧&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;身为一个开发人员，每天的工作就是在不断地异动 Source Code
      
    
    </summary>
    
    
      <category term="分享境" scheme="https://ghostsf.com/categories/%E5%88%86%E4%BA%AB%E5%A2%83/"/>
    
    
      <category term="AndroidStudio" scheme="https://ghostsf.com/tags/AndroidStudio/"/>
    
  </entry>
  
  <entry>
    <title>Could not retrieve transation read-only status server &amp;&amp; Communications link failure 异常</title>
    <link href="https://ghostsf.com/mybatis-mysql-error/"/>
    <id>https://ghostsf.com/mybatis-mysql-error/</id>
    <published>2019-11-04T10:46:36.000Z</published>
    <updated>2020-03-03T05:37:42.524Z</updated>
    
    <content type="html"><![CDATA[<p>上线的项目遇到一个问题。异常信息如下：</p><p>``</p><p>SQLException: Could not retrieve transation read-only status server</p><p>……</p><p>Caused by: com.mysql.jdbc.exceptions.jdbc4.CommunicationsException: Communications link failure</p><p>``</p><p>这两个异常问题，可以联想到的常见问题，无非是事务的问题或者是数据库连接的问题了。</p><p>事务方面 检查了mysql的事务隔离级别：</p><p><code>SHOW VARIABLES LIKE &#39;%iso%&#39;;</code></p><p>返回结果是：</p><p><code>READ-COMMITTED</code></p><blockquote><p>当数据库隔离级别为REPEATABLE-READ时，查询一个select语句也算是事物的开始。</p></blockquote><p>那这就不是这个原因导致的了。</p><p>再看连接的问题，</p><p>看一下数据库时间相关的设置：</p><p><code>show variables like &#39;%timeout%&#39;</code></p><p>返回结果是：</p><p>``</p><p>connect_timeout 10</p><p>delayed_insert_timeout 300</p><p>failover_resend_timeout</p><p>have_statement_timeout YES</p><p>innodb_flush_log_at_timeout 1</p><p>innodb_lock_wait_timeout 50</p><p>innodb_rollback_on_timeout OFF</p><p>interactive_timeout 7200</p><p>lock_wait_timeout 31536000</p><p>net_read_timeout 30</p><p>net_write_timeout 60</p><p>rocksdb_io_write_timeout 0</p><p>rocksdb_lock_wait_timeout 2</p><p>rpl_semi_sync_master_timeout 10000</p><p>rpl_semi_sync_slave_kill_conn_timeout 5</p><p>rpl_stop_slave_timeout 31536000</p><p>slave_net_timeout 60</p><p>thread_pool_idle_timeout 60</p><p>tokudb_last_lock_timeout</p><p>tokudb_lock_timeout 4000</p><p>tokudb_lock_timeout_debug 1</p><p>wait_timeout 7200</p><p>``</p><p>这也没什么问题。再多也不合理。</p><p>那可能就是本事mysql的驱动的问题了。</p><p>检查了下版本。再查了下，对应版本关系。</p><p><a href="https://dev.mysql.com/doc/connector-j/5.1/en/connector-j-versions.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/connector-j/5.1/en/connector-j-versions.html</a></p><p><a href="https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-versions.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-versions.html</a></p><p>官网瞄一眼</p><p>emmm，看到5.1的版本里有个Note</p><blockquote><p>MySQL Connector/J 8.0 is highly recommended for use with MySQL Server 8.0, 5.7, and 5.6. Please upgrade to MySQL Connector/J 8.0.</p></blockquote><p>那还说啥，升级到8.0咯</p><p>然后更新升级了上去，然后没问题了 …</p><p>Happy ending.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上线的项目遇到一个问题。异常信息如下：&lt;/p&gt;&lt;p&gt;``&lt;/p&gt;&lt;p&gt;SQLException: Could not retrieve transation read-only status server&lt;/p&gt;&lt;p&gt;……&lt;/p&gt;&lt;p&gt;Caused by: com.mysq
      
    
    </summary>
    
    
      <category term="技术栈" scheme="https://ghostsf.com/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="mysql" scheme="https://ghostsf.com/tags/mysql/"/>
    
      <category term="mybatis" scheme="https://ghostsf.com/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>nginx-proxy-read-responseheader-fail</title>
    <link href="https://ghostsf.com/nginx-proxy-read-responseheader-fail/"/>
    <id>https://ghostsf.com/nginx-proxy-read-responseheader-fail/</id>
    <published>2019-07-22T12:04:36.000Z</published>
    <updated>2020-03-03T05:37:42.524Z</updated>
    
    <content type="html"><![CDATA[<p>反向代理 recv() failed (104: Connection reset by peer) while reading response header from upstream错误</p><blockquote><p>原因就是请求的头文件过大导致502错误</p></blockquote><p><strong>解决方法就是提高头的缓存</strong></p><p>``<br>http {</p><pre><code>client_header_buffer_size 5m;location / {proxy_buffer_size 128k;proxy_busy_buffers_size 192k;proxy_buffers 4 192k;}</code></pre><p>}<br>``</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;反向代理 recv() failed (104: Connection reset by peer) while reading response header from upstream错误&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;原因就是请求的头文件过大导致502错误&lt;/p
      
    
    </summary>
    
    
      <category term="技术栈" scheme="https://ghostsf.com/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="nginx" scheme="https://ghostsf.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>代码可读性规范</title>
    <link href="https://ghostsf.com/code-readability/"/>
    <id>https://ghostsf.com/code-readability/</id>
    <published>2019-05-06T09:22:07.000Z</published>
    <updated>2020-03-03T05:37:42.520Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、可读性的重要性"><a href="#一、可读性的重要性" class="headerlink" title="一、可读性的重要性"></a>一、可读性的重要性</h1><p>编程有很大一部分时间是在阅读代码，不仅要阅读自己的代码，而且要阅读别人的代码。因此，可读性良好的代码能够大大提高编程效率。</p><p>可读性良好的代码往往会让代码架构更好，因为程序员更愿意去修改这部分代码，而且也更容易修改。</p><p>只有在核心领域为了效率才可以放弃可读性，否则可读性是第一位。</p><a id="more"></a><h1 id="二、用名字表达代码含义"><a href="#二、用名字表达代码含义" class="headerlink" title="二、用名字表达代码含义"></a>二、用名字表达代码含义</h1><p>一些比较有表达力的单词：</p><table><thead><tr><th align="center">单词</th><th>可替代单词</th></tr></thead><tbody><tr><td align="center">send</td><td>deliver、dispatch、announce、distribute、route</td></tr><tr><td align="center">find</td><td>search、extract、locate、recover</td></tr><tr><td align="center">start</td><td>launch、create、begin、open</td></tr><tr><td align="center">make</td><td>create、set up、build、generate、compose、add、new</td></tr></tbody></table><p>使用 i、j、k 作为循环迭代器的名字过于简单，user_i、member_i 这种名字会更有表达力。因为循环层次越多，代码越难理解，有表达力的迭代器名字可读性会更高。</p><p>为名字添加形容词等信息能让名字更具有表达力，但是名字也会变长。名字长短的准则是：作用域越大，名字越长。因此只有在短作用域才能使用一些简单名字。</p><h1 id="三、名字不能带来歧义"><a href="#三、名字不能带来歧义" class="headerlink" title="三、名字不能带来歧义"></a>三、名字不能带来歧义</h1><p>起完名字要思考一下别人会对这个名字有何解读，会不会误解了原本想表达的含义。</p><p>布尔相关的命名加上 is、can、should、has 等前缀。</p><ul><li>用 min、max 表示数量范围；</li><li>用 first、last 表示访问空间的包含范围；</li></ul><div align="center"><img src="pics/7d97dde0-0695-4707-bb68-e6c13a2e1b45.png" width="200px"></div><br><ul><li>begin、end 表示访问空间的排除范围，即 end 不包含尾部。</li></ul><div align="center"><img src="pics/d85870db-f28c-48c3-9d24-85a36fda5e51.png" width="200px"></div><br><h1 id="四、良好的代码风格"><a href="#四、良好的代码风格" class="headerlink" title="四、良好的代码风格"></a>四、良好的代码风格</h1><p>适当的空行和缩进。</p><p>排列整齐的注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;   <span class="comment">// 注释</span></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">11</span>;  <span class="comment">// 注释</span></span><br><span class="line"><span class="keyword">int</span> c = <span class="number">111</span>; <span class="comment">// 注释</span></span><br></pre></td></tr></table></figure><p>语句顺序不能随意，比如与 html 表单相关联的变量的赋值应该和表单在 html 中的顺序一致。</p><h1 id="五、为何编写注释"><a href="#五、为何编写注释" class="headerlink" title="五、为何编写注释"></a>五、为何编写注释</h1><p>阅读代码首先会注意到注释，如果注释没太大作用，那么就会浪费代码阅读的时间。那些能直接看出含义的代码不需要写注释，特别是并不需要为每个方法都加上注释，比如那些简单的 getter 和 setter 方法，为这些方法写注释反而让代码可读性更差。</p><p>不能因为有注释就随便起个名字，而是争取起个好名字而不写注释。</p><p>可以用注释来记录采用当前解决办法的思考过程，从而让读者更容易理解代码。</p><p>注释用来提醒一些特殊情况。</p><p>用 TODO 等做标记：</p><table><thead><tr><th>标记</th><th>用法</th></tr></thead><tbody><tr><td>TODO</td><td>待做</td></tr><tr><td>FIXME</td><td>待修复</td></tr><tr><td>HACK</td><td>粗糙的解决方案</td></tr><tr><td>XXX</td><td>危险！这里有重要的问题</td></tr></tbody></table><h1 id="六、如何编写注释"><a href="#六、如何编写注释" class="headerlink" title="六、如何编写注释"></a>六、如何编写注释</h1><p>尽量简洁明了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The first String is student's name</span></span><br><span class="line"><span class="comment">// The Second Integer is student's score</span></span><br><span class="line">Map&lt;String, Integer&gt; scoreMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Student's name -&gt; Student's score</span></span><br><span class="line">Map&lt;String, Integer&gt; scoreMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure><p>添加测试用例来说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// Example: add(1, 2), return 3</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用专业名词来缩短概念上的解释，比如用设计模式名来说明代码。</p><h1 id="七、提高控制流的可读性"><a href="#七、提高控制流的可读性" class="headerlink" title="七、提高控制流的可读性"></a>七、提高控制流的可读性</h1><p>条件表达式中，左侧是变量，右侧是常数。比如下面第一个语句正确：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (len &lt; <span class="number">10</span>)</span><br><span class="line"><span class="keyword">if</span> (<span class="number">10</span> &gt; len)</span><br></pre></td></tr></table></figure><p>只有在逻辑简单的情况下使用 ? : 三目运算符来使代码更紧凑，否则应该拆分成 if / else；</p><p>do / while 的条件放在后面，不够简单明了，并且会有一些迷惑的地方，最好使用 while 来代替。</p><p>如果只有一个 goto 目标，那么 goto 尚且还能接受，但是过于复杂的 goto 会让代码可读性特别差，应该避免使用 goto。</p><p>在嵌套的循环中，用一些 return 语句往往能减少嵌套的层数。</p><h1 id="八、拆分长表达式"><a href="#八、拆分长表达式" class="headerlink" title="八、拆分长表达式"></a>八、拆分长表达式</h1><p>长表达式的可读性很差，可以引入一些解释变量从而拆分表达式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> line.split(<span class="string">':'</span>)[<span class="number">0</span>].strip() == <span class="string">"root"</span>:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">username = line.split(<span class="string">':'</span>)[<span class="number">0</span>].strip()</span><br><span class="line"><span class="keyword">if</span> username == <span class="string">"root"</span>:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>使用摩根定理简化一些逻辑表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!a &amp;&amp; !b) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(a || b)) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="九、变量与可读性"><a href="#九、变量与可读性" class="headerlink" title="九、变量与可读性"></a>九、变量与可读性</h1><p><strong>去除控制流变量</strong> 。在循环中通过使用 break 或者 return 可以减少控制流变量的使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> done = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="comment">/* condition */</span> &amp;&amp; !done) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> ( ... ) &#123;</span><br><span class="line">        done = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="comment">/* condition */</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> ( ... ) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>减小变量作用域</strong> 。作用域越小，越容易定位到变量所有使用的地方。</p><p>JavaScript 可以用闭包减小作用域。以下代码中 submit_form 是函数变量，submitted 变量控制函数不会被提交两次。第一个实现中 submitted 是全局变量，第二个实现把 submitted 放到匿名函数中，从而限制了起作用域范围。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">submitted = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">var</span> submit_form = <span class="function"><span class="keyword">function</span>(<span class="params">form_name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (submitted) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    submitted = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> submit_form = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> submitted = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">form_name</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(submitted) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        submitted = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;());  <span class="comment">// () 使得外层匿名函数立即执行</span></span><br></pre></td></tr></table></figure><p>JavaScript 中没有用 var 声明的变量都是全局变量，而全局变量很容易造成迷惑，因此应当总是用 var 来声明变量。</p><p>变量定义的位置应当离它使用的位置最近。</p><p><strong>实例解析</strong></p><p>在一个网页中有以下文本输入字段：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">"text"</span> <span class="attr">id</span> = <span class="string">"input1"</span> <span class="attr">value</span> = <span class="string">"a"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">"text"</span> <span class="attr">id</span> = <span class="string">"input2"</span> <span class="attr">value</span> = <span class="string">"b"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">"text"</span> <span class="attr">id</span> = <span class="string">"input3"</span> <span class="attr">value</span> = <span class="string">""</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">"text"</span> <span class="attr">id</span> = <span class="string">"input4"</span> <span class="attr">value</span> = <span class="string">"d"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>现在要接受一个字符串并把它放到第一个空的 input 字段中，初始实现如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> setFirstEmptyInput = <span class="function"><span class="keyword">function</span>(<span class="params">new_alue</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> found = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> elem = <span class="built_in">document</span>.getElementById(<span class="string">'input'</span> + i);</span><br><span class="line">    <span class="keyword">while</span> (elem != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (elem.value === <span class="string">''</span>) &#123;</span><br><span class="line">            found = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">        elem = <span class="built_in">document</span>.getElementById(<span class="string">'input'</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (found) elem.value = new_value;</span><br><span class="line">    <span class="keyword">return</span> elem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上实现有以下问题：</p><ul><li>found 可以去除；</li><li>elem 作用域过大；</li><li>可以用 for 循环代替 while 循环；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> setFirstEmptyInput = <span class="function"><span class="keyword">function</span>(<span class="params">new_value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; <span class="literal">true</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> elem = <span class="built_in">document</span>.getElementById(<span class="string">'input'</span> + i);</span><br><span class="line">        <span class="keyword">if</span> (elem === <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (elem.value === <span class="string">''</span>) &#123;</span><br><span class="line">            elem.value = new_value;</span><br><span class="line">            <span class="keyword">return</span> elem;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="十、抽取函数"><a href="#十、抽取函数" class="headerlink" title="十、抽取函数"></a>十、抽取函数</h1><p>工程学就是把大问题拆分成小问题再把这些问题的解决方案放回一起。</p><p>首先应该明确一个函数的高层次目标，然后对于不是直接为了这个目标工作的代码，抽取出来放到独立的函数中。</p><p>介绍性的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findClostElement</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> clostIdx;</span><br><span class="line">    <span class="keyword">int</span> clostDist = Interger.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = ...;</span><br><span class="line">        <span class="keyword">int</span> y = ...;</span><br><span class="line">        <span class="keyword">int</span> z = ...;</span><br><span class="line">        <span class="keyword">int</span> value = x * y * z;</span><br><span class="line">        <span class="keyword">int</span> dist = Math.sqrt(Math.pow(value, <span class="number">2</span>), Math.pow(arr[i], <span class="number">2</span>));</span><br><span class="line">        <span class="keyword">if</span> (dist &lt; clostDist) &#123;</span><br><span class="line">            clostIdx = i;</span><br><span class="line">            clostDist = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> clostIdx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码中循环部分主要计算距离，这部分不属于代码高层次目标，高层次目标是寻找最小距离的值，因此可以把这部分代替提取到独立的函数中。这样做也带来一个额外的好处有：可以单独进行测试、可以快速找到程序错误并修改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findClostElement</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> clostIdx;</span><br><span class="line">    <span class="keyword">int</span> clostDist = Interger.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> dist = computDist(arr, i);</span><br><span class="line">        <span class="keyword">if</span> (dist &lt; clostDist) &#123;</span><br><span class="line">            clostIdx = i;</span><br><span class="line">            clostDist = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> clostIdx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并不是函数抽取的越多越好，如果抽取过多，在阅读代码的时候可能需要不断跳来跳去。只有在当前函数不需要去了解某一块代码细节而能够表达其内容时，把这块代码抽取成子函数才是好的。</p><p>函数抽取也用于减小代码的冗余。</p><h1 id="十一、一次只做一件事"><a href="#十一、一次只做一件事" class="headerlink" title="十一、一次只做一件事"></a>十一、一次只做一件事</h1><p>只做一件事的代码很容易让人知道其要做的事；</p><p>基本流程：列出代码所做的所有任务；把每个任务拆分到不同的函数，或者不同的段落。</p><h1 id="十二、用自然语言表述代码"><a href="#十二、用自然语言表述代码" class="headerlink" title="十二、用自然语言表述代码"></a>十二、用自然语言表述代码</h1><p>先用自然语言书写代码逻辑，也就是伪代码，然后再写代码，这样代码逻辑会更清晰。</p><h1 id="十三、减少代码量"><a href="#十三、减少代码量" class="headerlink" title="十三、减少代码量"></a>十三、减少代码量</h1><p>不要过度设计，编码过程会有很多变化，过度设计的内容到最后往往是无用的。</p><p>多用标准库实现。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、可读性的重要性&quot;&gt;&lt;a href=&quot;#一、可读性的重要性&quot; class=&quot;headerlink&quot; title=&quot;一、可读性的重要性&quot;&gt;&lt;/a&gt;一、可读性的重要性&lt;/h1&gt;&lt;p&gt;编程有很大一部分时间是在阅读代码，不仅要阅读自己的代码，而且要阅读别人的代码。因此，可读性良好的代码能够大大提高编程效率。&lt;/p&gt;&lt;p&gt;可读性良好的代码往往会让代码架构更好，因为程序员更愿意去修改这部分代码，而且也更容易修改。&lt;/p&gt;&lt;p&gt;只有在核心领域为了效率才可以放弃可读性，否则可读性是第一位。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术栈" scheme="https://ghostsf.com/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="代码规范" scheme="https://ghostsf.com/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>git-tips</title>
    <link href="https://ghostsf.com/git-tips/"/>
    <id>https://ghostsf.com/git-tips/</id>
    <published>2019-04-21T15:56:55.000Z</published>
    <updated>2020-03-03T05:37:42.520Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git的奇技淫巧"><a href="#Git的奇技淫巧" class="headerlink" title="Git的奇技淫巧:"></a>Git的奇技淫巧:</h1><blockquote><p>Git常用命令集合</p></blockquote><p>Git是一个 “分布式版本管理工具”，简单的理解版本管理工具：大家在写东西的时候都用过 “回撤” 这个功能，但是回撤只能回撤几步，假如想要找回我三天之前的修改，光用 “回撤” 是找不回来的。而 “版本管理工具” 能记录每次的修改，只要提交到版本仓库，你就可以找到之前任何时刻的状态（文本状态）。</p><p>下面的内容就是列举了常用的 Git 命令和一些小技巧，可以通过 “页面内查找” 的方式进行快速查询：<code>Ctrl/Command+f</code>。</p><h2 id="开卷必读"><a href="#开卷必读" class="headerlink" title="开卷必读"></a>开卷必读</h2><p><em>如果之前未使用过 Git，可以学习 <a href="http://rogerdudler.github.io/git-guide/index.zh.html" target="_blank" rel="noopener">Git 小白教程</a>入门</em></p><ol><li><strong>一定要先测试命令的效果后</strong>，再用于工作环境中，以防造成不能弥补的后果！<strong>到时候别拿着砍刀来找我</strong></li><li>所有的命令都在<code>git version 2.7.4 (Apple Git-66)</code>下测试通过</li><li>统一概念：<ul><li>工作区：改动（增删文件和内容）</li><li>暂存区：输入命令：<code>git add 改动的文件名</code>，此次改动就放到了 ‘暂存区’</li><li>本地仓库(简称：本地)：输入命令：<code>git commit 此次修改的描述</code>，此次改动就放到了 ’本地仓库’，每个 commit，我叫它为一个 ‘版本’。</li><li>远程仓库(简称：远程)：输入命令：<code>git push 远程仓库</code>，此次改动就放到了 ‘远程仓库’（GitHub 等)</li><li>commit-id：输出命令：<code>git log</code>，最上面那行 <code>commit xxxxxx</code>，后面的字符串就是 commit-id<a id="more"></a></li></ul></li></ol><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#展示帮助信息">展示帮助信息</a></li><li><a href="#回到远程仓库的状态">回到远程仓库的状态</a></li><li><a href="#重设第一个-commit">重设第一个commit</a></li><li><a href="#展示工作区和暂存区的不同">展示工作区和暂存区的不同</a></li><li><a href="#展示暂存区和最近版本的不同">展示暂存区和最近版本的不同</a></li><li><a href="#展示暂存区工作区和最近版本的不同">展示暂存区、工作区和最近版本的不同</a></li><li><a href="#快速切换到上一个分支">快速切换到上一个分支</a></li><li><a href="#删除已经合并到-master-的分支">删除已经合并到 master 的分支</a></li><li><a href="#展示本地分支关联远程仓库的情况">展示本地分支关联远程仓库的情况</a></li><li><a href="#关联远程分支">关联远程分支</a></li><li><a href="#列出所有远程分支">列出所有远程分支</a></li><li><a href="#列出本地和远程分支">列出本地和远程分支</a></li><li><a href="#创建并切换到本地分支">创建并切换到本地分支</a></li><li><a href="#从远程分支中创建并切换到本地分支">从远程分支中创建并切换到本地分支</a></li><li><a href="#删除本地分支">删除本地分支</a></li><li><a href="#删除远程分支">删除远程分支</a></li><li><a href="#重命名本地分支">重命名本地分支</a></li><li><a href="#查看标签">查看标签</a></li><li><a href="#查看标签详细信息">查看标签详细信息</a></li><li><a href="#本地创建标签">本地创建标签</a></li><li><a href="#推送标签到远程仓库">推送标签到远程仓库</a></li><li><a href="#删除本地标签">删除本地标签</a></li><li><a href="#删除远程标签">删除远程标签</a></li><li><a href="#切回到某个标签">切回到某个标签</a></li><li><a href="#放弃工作区的修改">放弃工作区的修改</a></li><li><a href="#恢复删除的文件">恢复删除的文件</a></li><li><a href="#以新增一个-commit-的方式还原某一个-commit-的修改">以新增一个 commit 的方式还原某一个 commit 的修改</a></li><li><a href="#回到某个-commit-的状态并删除后面的-commit">回到某个 commit 的状态，并删除后面的 commit</a></li><li><a href="#修改上一个-commit-的描述">修改上一个 commit 的描述</a></li><li><a href="#查看-commit-历史">查看 commit 历史</a></li><li><a href="#显示本地更新过-head-的-git-命令记录">显示本地更新过 HEAD 的 git 命令记录</a></li><li><a href="#修改作者名">修改作者名</a></li><li><a href="#修改远程仓库的-url">修改远程仓库的 url</a></li><li><a href="#增加远程仓库">增加远程仓库</a></li><li><a href="#列出所有远程仓库">列出所有远程仓库</a></li><li><a href="#查看两个星期内的改动">查看两个星期内的改动</a></li><li><a href="#把-A-分支的某一个-commit-放到-B-分支上">把 A 分支的某一个 commit，放到 B 分支上</a></li><li><a href="#给-git-命令起别名">给 git 命令起别名</a></li><li><a href="#存储当前的修改但不用提交-commit">存储当前的修改，但不用提交 commit</a></li><li><a href="#保存当前状态包括-untracked-的文件">保存当前状态，包括 untracked 的文件</a></li><li><a href="#展示所有-stashes">展示所有 stashes</a></li><li><a href="#回到某个-stash-的状态">回到某个 stash 的状态</a></li><li><a href="#回到最后一个-stash-的状态并删除这个-stash">回到最后一个 stash 的状态，并删除这个 stash</a></li><li><a href="#删除所有的-stash">删除所有的 stash</a></li><li><a href="#从-stash-中拿出某个文件的修改">从 stash 中拿出某个文件的修改</a></li><li><a href="#展示所有-tracked-的文件">展示所有 tracked 的文件</a></li><li><a href="#展示所有-untracked-的文件">展示所有 untracked 的文件</a></li><li><a href="#展示所有忽略的文件">展示所有忽略的文件</a></li><li><a href="#强制删除-untracked-的文件">强制删除 untracked 的文件</a></li><li><a href="#强制删除-untracked-的目录">强制删除 untracked 的目录</a></li><li><a href="#展示简化的-commit-历史">展示简化的 commit 历史</a></li><li><a href="#查看某段代码是谁写的">查看某段代码是谁写的</a></li><li><a href="#把某一个分支到导出成一个文件">把某一个分支到导出成一个文件</a></li><li><a href="#从包中导入分支">从包中导入分支</a></li><li><a href="#执行-rebase-之前自动-stash">执行 rebase 之前自动 stash</a></li><li><a href="#从远程仓库根据-ID-拉下某一状态-到本地分支">从远程仓库根据 ID，拉下某一状态，到本地分支</a></li><li><a href="#详细展示一行中的修改">详细展示一行中的修改</a></li><li><a href="#清除-gitignore-文件中记录的文件">清除 <code>.gitignore</code> 文件中记录的文件</a></li><li><a href="#展示所有-alias-和-configs">展示所有 alias 和 configs</a></li><li><a href="#展示忽略的文件">展示忽略的文件</a></li><li><a href="#commit-历史中显示-Branch1-有的但是-Branch2-没有-commit">commit 历史中显示 Branch1 有的，但是 Branch2 没有 commit</a></li><li><a href="#在-commit-log-中显示-GPG-签名">在 commit log 中显示 GPG 签名</a></li><li><a href="#删除全局设置">删除全局设置</a></li><li><a href="#新建并切换到新分支上同时这个分支没有任何-commit">新建并切换到新分支上，同时这个分支没有任何 commit</a></li><li><a href="#展示任意分支某一文件的内容">展示任意分支某一文件的内容</a></li><li><a href="#clone-下来指定的单一分支">clone 下来指定的单一分支</a></li><li><a href="#忽略某个文件的改动">忽略某个文件的改动</a></li><li><a href="#忽略文件的权限变化">忽略文件的权限变化</a></li><li><a href="#以最后提交的顺序列出所有-Git-分支">以最后提交的顺序列出所有 Git 分支</a></li><li><a href="#在-commit-log-中查找相关内容">在 commit log 中查找相关内容</a></li><li><a href="#把暂存区的指定-file-放到工作区中">把暂存区的指定 file 放到工作区中</a></li><li><a href="#强制推送">强制推送</a></li><li><a href="#一图详解">一图详解</a></li><li><a href="#优雅的提交Commit信息">优雅的提交Commit信息</a></li><li><a href="#联系我">联系我</a></li></ul><h2 id="展示帮助信息"><a href="#展示帮助信息" class="headerlink" title="展示帮助信息"></a>展示帮助信息</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">help</span> -g</span><br></pre></td></tr></table></figure><p>The command output as below:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">The common Git guides are:</span><br><span class="line">   attributes          Defining attributes per path</span><br><span class="line">   cli                 Git command-line interface and conventions</span><br><span class="line">   core-tutorial       A Git core tutorial for developers</span><br><span class="line">   cvs-migration       Git for CVS users</span><br><span class="line">   diffcore            Tweaking diff output</span><br><span class="line">   everyday            A useful minimum set of commands for Everyday Git</span><br><span class="line">   glossary            A Git Glossary</span><br><span class="line">   hooks               Hooks used by Git</span><br><span class="line">   ignore              Specifies intentionally untracked files to ignore</span><br><span class="line">   modules             Defining submodule properties</span><br><span class="line">   namespaces          Git namespaces</span><br><span class="line">   repository-layout    Git Repository Layout</span><br><span class="line">   revisions           Specifying revisions and ranges for Git</span><br><span class="line">   tutorial            A tutorial introduction to Git</span><br><span class="line">   tutorial-2          A tutorial introduction to Git: part two</span><br><span class="line">   workflows           An overview of recommended workflows with Git</span><br><span class="line"></span><br><span class="line">&#39;git help -a&#39; and &#39;git help -g&#39; list available subcommands and some concept guides. See &#39;git help &lt;command&gt;&#39; or &#39;git help &lt;concept&gt;&#39; to read about a specific subcommand or concept.</span><br></pre></td></tr></table></figure><h2 id="回到远程仓库的状态"><a href="#回到远程仓库的状态" class="headerlink" title="回到远程仓库的状态"></a>回到远程仓库的状态</h2><p>抛弃本地所有的修改，回到远程仓库的状态。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch --all &amp;&amp; git reset --hard origin/master</span><br></pre></td></tr></table></figure><h2 id="重设第一个-commit"><a href="#重设第一个-commit" class="headerlink" title="重设第一个 commit"></a>重设第一个 commit</h2><p>也就是把所有的改动都重新放回工作区，并<strong>清空所有的 commit</strong>，这样就可以重新提交第一个 commit 了</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git update-ref -d HEAD</span><br></pre></td></tr></table></figure><h2 id="展示工作区和暂存区的不同"><a href="#展示工作区和暂存区的不同" class="headerlink" title="展示工作区和暂存区的不同"></a>展示工作区和暂存区的不同</h2><p>输出<strong>工作区</strong>和<strong>暂存区</strong>的 different (不同)。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></table></figure><p>还可以展示本地仓库中任意两个 commit 之间的文件变动：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff &lt;commit-id&gt; &lt;commit-id&gt;</span><br></pre></td></tr></table></figure><h2 id="展示暂存区和最近版本的不同"><a href="#展示暂存区和最近版本的不同" class="headerlink" title="展示暂存区和最近版本的不同"></a>展示暂存区和最近版本的不同</h2><p>输出<strong>暂存区</strong>和本地最近的版本 (commit) 的 different (不同)。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff --cached</span><br></pre></td></tr></table></figure><h2 id="展示暂存区、工作区和最近版本的不同"><a href="#展示暂存区、工作区和最近版本的不同" class="headerlink" title="展示暂存区、工作区和最近版本的不同"></a>展示暂存区、工作区和最近版本的不同</h2><p>输出<strong>工作区</strong>、<strong>暂存区</strong> 和本地最近的版本 (commit) 的 different (不同)。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff HEAD</span><br></pre></td></tr></table></figure><h2 id="快速切换到上一个分支"><a href="#快速切换到上一个分支" class="headerlink" title="快速切换到上一个分支"></a>快速切换到上一个分支</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -</span><br></pre></td></tr></table></figure><h2 id="删除已经合并到-master-的分支"><a href="#删除已经合并到-master-的分支" class="headerlink" title="删除已经合并到 master 的分支"></a>删除已经合并到 master 的分支</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --merged master | grep -v <span class="string">'^\*\|  master'</span> | xargs -n 1 git branch -d</span><br></pre></td></tr></table></figure><h2 id="展示本地分支关联远程仓库的情况"><a href="#展示本地分支关联远程仓库的情况" class="headerlink" title="展示本地分支关联远程仓库的情况"></a>展示本地分支关联远程仓库的情况</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -vv</span><br></pre></td></tr></table></figure><h2 id="关联远程分支"><a href="#关联远程分支" class="headerlink" title="关联远程分支"></a>关联远程分支</h2><p>关联之后，<code>git branch -vv</code> 就可以展示关联的远程分支名了，同时推送到远程仓库直接：<code>git push</code>，不需要指定远程仓库了。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -u origin/mybranch</span><br></pre></td></tr></table></figure><p>或者在 push 时加上 <code>-u</code> 参数</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin/mybranch -u</span><br></pre></td></tr></table></figure><h2 id="列出所有远程分支"><a href="#列出所有远程分支" class="headerlink" title="列出所有远程分支"></a>列出所有远程分支</h2><p>-r 参数相当于：remote</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -r</span><br></pre></td></tr></table></figure><h2 id="列出本地和远程分支"><a href="#列出本地和远程分支" class="headerlink" title="列出本地和远程分支"></a>列出本地和远程分支</h2><p>-a 参数相当于：all</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure><h2 id="创建并切换到本地分支"><a href="#创建并切换到本地分支" class="headerlink" title="创建并切换到本地分支"></a>创建并切换到本地分支</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><h2 id="从远程分支中创建并切换到本地分支"><a href="#从远程分支中创建并切换到本地分支" class="headerlink" title="从远程分支中创建并切换到本地分支"></a>从远程分支中创建并切换到本地分支</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b &lt;branch-name&gt; origin/&lt;branch-name&gt;</span><br></pre></td></tr></table></figure><h2 id="删除本地分支"><a href="#删除本地分支" class="headerlink" title="删除本地分支"></a>删除本地分支</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d &lt;<span class="built_in">local</span>-branchname&gt;</span><br></pre></td></tr></table></figure><h2 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin --delete &lt;remote-branchname&gt;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin :&lt;remote-branchname&gt;</span><br></pre></td></tr></table></figure><h2 id="重命名本地分支"><a href="#重命名本地分支" class="headerlink" title="重命名本地分支"></a>重命名本地分支</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -m &lt;new-branch-name&gt;</span><br></pre></td></tr></table></figure><h2 id="查看标签"><a href="#查看标签" class="headerlink" title="查看标签"></a>查看标签</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag</span><br></pre></td></tr></table></figure><p>展示当前分支的最近的 tag</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git describe --tags --abbrev=0</span><br></pre></td></tr></table></figure><h2 id="查看标签详细信息"><a href="#查看标签详细信息" class="headerlink" title="查看标签详细信息"></a>查看标签详细信息</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -ln</span><br></pre></td></tr></table></figure><h2 id="本地创建标签"><a href="#本地创建标签" class="headerlink" title="本地创建标签"></a>本地创建标签</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag &lt;version-number&gt;</span><br></pre></td></tr></table></figure><p>默认 tag 是打在最近的一次 commit 上，如果需要指定 commit 打 tag：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -a &lt;version-number&gt; -m <span class="string">"v1.0 发布(描述)"</span> &lt;commit-id&gt;</span><br></pre></td></tr></table></figure><h2 id="推送标签到远程仓库"><a href="#推送标签到远程仓库" class="headerlink" title="推送标签到远程仓库"></a>推送标签到远程仓库</h2><p>首先要保证本地创建好了标签才可以推送标签到远程仓库：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin &lt;<span class="built_in">local</span>-version-number&gt;</span><br></pre></td></tr></table></figure><p>一次性推送所有标签，同步到远程仓库：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin --tags</span><br></pre></td></tr></table></figure><h2 id="删除本地标签"><a href="#删除本地标签" class="headerlink" title="删除本地标签"></a>删除本地标签</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -d &lt;tag-name&gt;</span><br></pre></td></tr></table></figure><h2 id="删除远程标签"><a href="#删除远程标签" class="headerlink" title="删除远程标签"></a>删除远程标签</h2><p>删除远程标签需要<strong>先删除本地标签</strong>，再执行下面的命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin :refs/tags/&lt;tag-name&gt;</span><br></pre></td></tr></table></figure><h2 id="切回到某个标签"><a href="#切回到某个标签" class="headerlink" title="切回到某个标签"></a>切回到某个标签</h2><p>一般上线之前都会打 tag，就是为了防止上线后出现问题，方便快速回退到上一版本。下面的命令是回到某一标签下的状态：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b branch_name tag_name</span><br></pre></td></tr></table></figure><h2 id="放弃工作区的修改"><a href="#放弃工作区的修改" class="headerlink" title="放弃工作区的修改"></a>放弃工作区的修改</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;file-name&gt;</span><br></pre></td></tr></table></figure><p>放弃所有修改：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout .</span><br></pre></td></tr></table></figure><h2 id="恢复删除的文件"><a href="#恢复删除的文件" class="headerlink" title="恢复删除的文件"></a>恢复删除的文件</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git rev-list -n 1 HEAD -- &lt;file_path&gt; <span class="comment">#得到 deleting_commit</span></span><br><span class="line"></span><br><span class="line">git checkout &lt;deleting_commit&gt;^ -- &lt;file_path&gt; <span class="comment">#回到删除文件 deleting_commit 之前的状态</span></span><br></pre></td></tr></table></figure><h2 id="以新增一个-commit-的方式还原某一个-commit-的修改"><a href="#以新增一个-commit-的方式还原某一个-commit-的修改" class="headerlink" title="以新增一个 commit 的方式还原某一个 commit 的修改"></a>以新增一个 commit 的方式还原某一个 commit 的修改</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert &lt;commit-id&gt;</span><br></pre></td></tr></table></figure><h2 id="回到某个-commit-的状态，并删除后面的-commit"><a href="#回到某个-commit-的状态，并删除后面的-commit" class="headerlink" title="回到某个 commit 的状态，并删除后面的 commit"></a>回到某个 commit 的状态，并删除后面的 commit</h2><p>和 revert 的区别：reset 命令会抹去某个 commit id 之后的所有 commit</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git reset &lt;commit-id&gt;  <span class="comment">#默认就是-mixed参数。</span></span><br><span class="line"></span><br><span class="line">git reset –mixed HEAD^  <span class="comment">#回退至上个版本，它将重置HEAD到另外一个commit,并且重置暂存区以便和HEAD相匹配，但是也到此为止。工作区不会被更改。</span></span><br><span class="line"></span><br><span class="line">git reset –soft HEAD~3  <span class="comment">#回退至三个版本之前，只回退了commit的信息，暂存区和工作区与回退之前保持一致。如果还要提交，直接commit即可  </span></span><br><span class="line"></span><br><span class="line">git reset –hard &lt;commit-id&gt;  <span class="comment">#彻底回退到指定commit-id的状态，暂存区和工作区也会变为指定commit-id版本的内容</span></span><br></pre></td></tr></table></figure><h2 id="修改上一个-commit-的描述"><a href="#修改上一个-commit-的描述" class="headerlink" title="修改上一个 commit 的描述"></a>修改上一个 commit 的描述</h2><p>如果暂存区有改动，同时也会将暂存区的改动提交到上一个 commit</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure><h2 id="查看-commit-历史"><a href="#查看-commit-历史" class="headerlink" title="查看 commit 历史"></a>查看 commit 历史</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure><h2 id="查看某段代码是谁写的"><a href="#查看某段代码是谁写的" class="headerlink" title="查看某段代码是谁写的"></a>查看某段代码是谁写的</h2><p>blame 的意思为‘责怪’，你懂的。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git blame &lt;file-name&gt;</span><br></pre></td></tr></table></figure><h2 id="显示本地更新过-HEAD-的-git-命令记录"><a href="#显示本地更新过-HEAD-的-git-命令记录" class="headerlink" title="显示本地更新过 HEAD 的 git 命令记录"></a>显示本地更新过 HEAD 的 git 命令记录</h2><p>每次更新了 HEAD 的 git 命令比如 commint、amend、cherry-pick、reset、revert 等都会被记录下来（不限分支），就像 shell 的 history 一样。<br>这样你可以 reset 到任何一次更新了 HEAD 的操作之后，而不仅仅是回到当前分支下的某个 commit 之后的状态。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure><h2 id="修改作者名"><a href="#修改作者名" class="headerlink" title="修改作者名"></a>修改作者名</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend --author=<span class="string">'Author Name &lt;email@address.com&gt;'</span></span><br></pre></td></tr></table></figure><h2 id="修改远程仓库的-url"><a href="#修改远程仓库的-url" class="headerlink" title="修改远程仓库的 url"></a>修改远程仓库的 url</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote <span class="built_in">set</span>-url origin &lt;URL&gt;</span><br></pre></td></tr></table></figure><h2 id="增加远程仓库"><a href="#增加远程仓库" class="headerlink" title="增加远程仓库"></a>增加远程仓库</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin &lt;remote-url&gt;</span><br></pre></td></tr></table></figure><h2 id="列出所有远程仓库"><a href="#列出所有远程仓库" class="headerlink" title="列出所有远程仓库"></a>列出所有远程仓库</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote</span><br></pre></td></tr></table></figure><h2 id="查看两个星期内的改动"><a href="#查看两个星期内的改动" class="headerlink" title="查看两个星期内的改动"></a>查看两个星期内的改动</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git whatchanged --since=<span class="string">'2 weeks ago'</span></span><br></pre></td></tr></table></figure><h2 id="把-A-分支的某一个-commit，放到-B-分支上"><a href="#把-A-分支的某一个-commit，放到-B-分支上" class="headerlink" title="把 A 分支的某一个 commit，放到 B 分支上"></a>把 A 分支的某一个 commit，放到 B 分支上</h2><p>这个过程需要 <code>cherry-pick</code> 命令，<a href="http://sg552.iteye.com/blog/1300713#bc2367928" target="_blank" rel="noopener">参考</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;branch-name&gt; &amp;&amp; git cherry-pick &lt;commit-id&gt;</span><br></pre></td></tr></table></figure><h2 id="给-git-命令起别名"><a href="#给-git-命令起别名" class="headerlink" title="给 git 命令起别名"></a>给 git 命令起别名</h2><p>简化命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git config --global <span class="built_in">alias</span>.&lt;handle&gt; &lt;<span class="built_in">command</span>&gt;</span><br><span class="line"></span><br><span class="line">比如：git status 改成 git st，这样可以简化命令</span><br><span class="line"></span><br><span class="line">git config --global alias.st status</span><br></pre></td></tr></table></figure><h2 id="存储当前的修改，但不用提交-commit"><a href="#存储当前的修改，但不用提交-commit" class="headerlink" title="存储当前的修改，但不用提交 commit"></a>存储当前的修改，但不用提交 commit</h2><p>详解可以参考<a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137602359178794d966923e5c4134bc8bf98dfb03aea3000" target="_blank" rel="noopener">廖雪峰老师的 git 教程</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure><h2 id="保存当前状态，包括-untracked-的文件"><a href="#保存当前状态，包括-untracked-的文件" class="headerlink" title="保存当前状态，包括 untracked 的文件"></a>保存当前状态，包括 untracked 的文件</h2><p>untracked 文件：新建的文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash -u</span><br></pre></td></tr></table></figure><h2 id="展示所有-stashes"><a href="#展示所有-stashes" class="headerlink" title="展示所有 stashes"></a>展示所有 stashes</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash list</span><br></pre></td></tr></table></figure><h2 id="回到某个-stash-的状态"><a href="#回到某个-stash-的状态" class="headerlink" title="回到某个 stash 的状态"></a>回到某个 stash 的状态</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash apply &lt;stash@&#123;n&#125;&gt;</span><br></pre></td></tr></table></figure><h2 id="回到最后一个-stash-的状态，并删除这个-stash"><a href="#回到最后一个-stash-的状态，并删除这个-stash" class="headerlink" title="回到最后一个 stash 的状态，并删除这个 stash"></a>回到最后一个 stash 的状态，并删除这个 stash</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash pop</span><br></pre></td></tr></table></figure><h2 id="删除所有的-stash"><a href="#删除所有的-stash" class="headerlink" title="删除所有的 stash"></a>删除所有的 stash</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash clear</span><br></pre></td></tr></table></figure><h2 id="从-stash-中拿出某个文件的修改"><a href="#从-stash-中拿出某个文件的修改" class="headerlink" title="从 stash 中拿出某个文件的修改"></a>从 stash 中拿出某个文件的修改</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;stash@&#123;n&#125;&gt; -- &lt;file-path&gt;</span><br></pre></td></tr></table></figure><h2 id="展示所有-tracked-的文件"><a href="#展示所有-tracked-的文件" class="headerlink" title="展示所有 tracked 的文件"></a>展示所有 tracked 的文件</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git ls-files -t</span><br></pre></td></tr></table></figure><h2 id="展示所有-untracked-的文件"><a href="#展示所有-untracked-的文件" class="headerlink" title="展示所有 untracked 的文件"></a>展示所有 untracked 的文件</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git ls-files --others</span><br></pre></td></tr></table></figure><h2 id="展示所有忽略的文件"><a href="#展示所有忽略的文件" class="headerlink" title="展示所有忽略的文件"></a>展示所有忽略的文件</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git ls-files --others -i --exclude-standard</span><br></pre></td></tr></table></figure><h2 id="强制删除-untracked-的文件"><a href="#强制删除-untracked-的文件" class="headerlink" title="强制删除 untracked 的文件"></a>强制删除 untracked 的文件</h2><p>可以用来删除新建的文件。如果不指定文件文件名，则清空所有工作的 untracked 文件。<code>clean</code> 命令，<strong>注意两点</strong>：</p><ol><li>clean 后，删除的文件无法找回</li><li>不会影响 tracked 的文件的改动，只会删除 untracked 的文件</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clean &lt;file-name&gt; -f</span><br></pre></td></tr></table></figure><h2 id="强制删除-untracked-的目录"><a href="#强制删除-untracked-的目录" class="headerlink" title="强制删除 untracked 的目录"></a>强制删除 untracked 的目录</h2><p>可以用来删除新建的目录，<strong>注意</strong>:这个命令也可以用来删除 untracked 的文件。详情见上一条</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clean &lt;directory-name&gt; -df</span><br></pre></td></tr></table></figure><h2 id="展示简化的-commit-历史"><a href="#展示简化的-commit-历史" class="headerlink" title="展示简化的 commit 历史"></a>展示简化的 commit 历史</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --pretty=oneline --graph --decorate --all</span><br></pre></td></tr></table></figure><h2 id="把某一个分支到导出成一个文件"><a href="#把某一个分支到导出成一个文件" class="headerlink" title="把某一个分支到导出成一个文件"></a>把某一个分支到导出成一个文件</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git bundle create &lt;file&gt; &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><h2 id="从包中导入分支"><a href="#从包中导入分支" class="headerlink" title="从包中导入分支"></a>从包中导入分支</h2><p>新建一个分支，分支内容就是上面 <code>git bundle create</code> 命令导出的内容</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> repo.bundle &lt;repo-dir&gt; -b &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><h2 id="执行-rebase-之前自动-stash"><a href="#执行-rebase-之前自动-stash" class="headerlink" title="执行 rebase 之前自动 stash"></a>执行 rebase 之前自动 stash</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase --autostash</span><br></pre></td></tr></table></figure><h2 id="从远程仓库根据-ID，拉下某一状态，到本地分支"><a href="#从远程仓库根据-ID，拉下某一状态，到本地分支" class="headerlink" title="从远程仓库根据 ID，拉下某一状态，到本地分支"></a>从远程仓库根据 ID，拉下某一状态，到本地分支</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin pull/&lt;id&gt;/head:&lt;branch-name&gt;</span><br></pre></td></tr></table></figure><h2 id="详细展示一行中的修改"><a href="#详细展示一行中的修改" class="headerlink" title="详细展示一行中的修改"></a>详细展示一行中的修改</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff --word-diff</span><br></pre></td></tr></table></figure><h2 id="清除-gitignore-文件中记录的文件"><a href="#清除-gitignore-文件中记录的文件" class="headerlink" title="清除 gitignore 文件中记录的文件"></a>清除 gitignore 文件中记录的文件</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clean -X -f</span><br></pre></td></tr></table></figure><h2 id="展示所有-alias-和-configs"><a href="#展示所有-alias-和-configs" class="headerlink" title="展示所有 alias 和 configs"></a>展示所有 alias 和 configs</h2><p><strong>注意：</strong> config 分为：当前目录（local）和全局（golbal）的 config，默认为当前目录的 config</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --<span class="built_in">local</span> --list (当前目录)</span><br><span class="line">git config --global --list (全局)</span><br></pre></td></tr></table></figure><h2 id="展示忽略的文件"><a href="#展示忽略的文件" class="headerlink" title="展示忽略的文件"></a>展示忽略的文件</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status --ignored</span><br></pre></td></tr></table></figure><h2 id="commit-历史中显示-Branch1-有的，但是-Branch2-没有-commit"><a href="#commit-历史中显示-Branch1-有的，但是-Branch2-没有-commit" class="headerlink" title="commit 历史中显示 Branch1 有的，但是 Branch2 没有 commit"></a>commit 历史中显示 Branch1 有的，但是 Branch2 没有 commit</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> Branch1 ^Branch2</span><br></pre></td></tr></table></figure><h2 id="在-commit-log-中显示-GPG-签名"><a href="#在-commit-log-中显示-GPG-签名" class="headerlink" title="在 commit log 中显示 GPG 签名"></a>在 commit log 中显示 GPG 签名</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --show-signature</span><br></pre></td></tr></table></figure><h2 id="删除全局设置"><a href="#删除全局设置" class="headerlink" title="删除全局设置"></a>删除全局设置</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global --<span class="built_in">unset</span> &lt;entry-name&gt;</span><br></pre></td></tr></table></figure><h2 id="新建并切换到新分支上，同时这个分支没有任何-commit"><a href="#新建并切换到新分支上，同时这个分支没有任何-commit" class="headerlink" title="新建并切换到新分支上，同时这个分支没有任何 commit"></a>新建并切换到新分支上，同时这个分支没有任何 commit</h2><p>相当于保存修改，但是重写 commit 历史</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout --orphan &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><h2 id="展示任意分支某一文件的内容"><a href="#展示任意分支某一文件的内容" class="headerlink" title="展示任意分支某一文件的内容"></a>展示任意分支某一文件的内容</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git show &lt;branch-name&gt;:&lt;file-name&gt;</span><br></pre></td></tr></table></figure><h2 id="clone-下来指定的单一分支"><a href="#clone-下来指定的单一分支" class="headerlink" title="clone 下来指定的单一分支"></a>clone 下来指定的单一分支</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b &lt;branch-name&gt; --single-branch https://github.com/user/repo.git</span><br></pre></td></tr></table></figure><h2 id="忽略某个文件的改动"><a href="#忽略某个文件的改动" class="headerlink" title="忽略某个文件的改动"></a>忽略某个文件的改动</h2><p>关闭 track 指定文件的改动，也就是 Git 将不会在记录这个文件的改动</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git update-index --assume-unchanged path/to/file</span><br></pre></td></tr></table></figure><p>恢复 track 指定文件的改动</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git update-index --no-assume-unchanged path/to/file</span><br></pre></td></tr></table></figure><h2 id="忽略文件的权限变化"><a href="#忽略文件的权限变化" class="headerlink" title="忽略文件的权限变化"></a>忽略文件的权限变化</h2><p>不再将文件的权限变化视作改动</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config core.fileMode <span class="literal">false</span></span><br></pre></td></tr></table></figure><h2 id="以最后提交的顺序列出所有-Git-分支"><a href="#以最后提交的顺序列出所有-Git-分支" class="headerlink" title="以最后提交的顺序列出所有 Git 分支"></a>以最后提交的顺序列出所有 Git 分支</h2><p>最新的放在最上面</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">for</span>-each-ref --sort=-committerdate --format=<span class="string">'%(refname:short)'</span> refs/heads/</span><br></pre></td></tr></table></figure><h2 id="在-commit-log-中查找相关内容"><a href="#在-commit-log-中查找相关内容" class="headerlink" title="在 commit log 中查找相关内容"></a>在 commit log 中查找相关内容</h2><p>通过 grep 查找，given-text：所需要查找的字段</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --all --grep=<span class="string">'&lt;given-text&gt;'</span></span><br></pre></td></tr></table></figure><h2 id="把暂存区的指定-file-放到工作区中"><a href="#把暂存区的指定-file-放到工作区中" class="headerlink" title="把暂存区的指定 file 放到工作区中"></a>把暂存区的指定 file 放到工作区中</h2><p>不添加参数，默认是 <code>-mixed</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset &lt;file-name&gt;</span><br></pre></td></tr></table></figure><h2 id="强制推送"><a href="#强制推送" class="headerlink" title="强制推送"></a>强制推送</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -f &lt;remote-name&gt; &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><h2 id="一图详解"><a href="#一图详解" class="headerlink" title="一图详解"></a>一图详解</h2><p><img src="../images/post/git.png" alt=""></p><h2 id="优雅的提交Commit信息"><a href="#优雅的提交Commit信息" class="headerlink" title="优雅的提交Commit信息"></a>优雅的提交Commit信息</h2><p>使用<a href="https://github.com/angular/angular.js/blob/master/DEVELOPERS.md#-git-commit-guidelines" target="_blank" rel="noopener">Angular团队提交规范</a></p><p>主要有以下组成</p><ul><li>标题行: 必填, 描述主要修改类型和内容</li><li>主题内容: 描述为什么修改, 做了什么样的修改, 以及开发的思路等等</li><li>页脚注释: 放 Breaking Changes 或 Closed Issues</li></ul><p>常用的修改项</p><ul><li>type: commit 的类型</li><li>feat: 新特性</li><li>fix: 修改问题</li><li>refactor: 代码重构</li><li>docs: 文档修改</li><li>style: 代码格式修改, 注意不是 css 修改</li><li>test: 测试用例修改</li><li>chore: 其他修改, 比如构建流程, 依赖管理.</li><li>scope: commit 影响的范围, 比如: route, component, utils, build…</li><li>subject: commit 的概述</li><li>body: commit 具体修改内容, 可以分为多行</li><li>footer: 一些备注, 通常是 BREAKING CHANGE 或修复的 bug 的链接.</li></ul><h3 id="使用Commitizen代替-git-commit"><a href="#使用Commitizen代替-git-commit" class="headerlink" title="使用Commitizen代替 git commit"></a>使用<code>Commitizen</code>代替 git commit</h3><p>可以使用<a href="https://github.com/commitizen/cz-cli" target="_blank" rel="noopener">cz-cli</a>工具代替 <code>git commit</code></p><p>全局安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install -g commitizen cz-conventional-changelog</span><br><span class="line"></span><br><span class="line">echo '&#123; "path": "cz-conventional-changelog" &#125;' &gt; ~/.czrc</span><br></pre></td></tr></table></figure><p>全局安装后使用 <code>git cz</code> 代替 <code>git commit</code>就可以了,如下图</p><p><img src="../images/post/gitcz.png" alt=""></p><p><strong><a href="#目录">⬆ 返回顶部</a></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Git的奇技淫巧&quot;&gt;&lt;a href=&quot;#Git的奇技淫巧&quot; class=&quot;headerlink&quot; title=&quot;Git的奇技淫巧:&quot;&gt;&lt;/a&gt;Git的奇技淫巧:&lt;/h1&gt;&lt;blockquote&gt;&lt;p&gt;Git常用命令集合&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Git是一个 “分布式版本管理工具”，简单的理解版本管理工具：大家在写东西的时候都用过 “回撤” 这个功能，但是回撤只能回撤几步，假如想要找回我三天之前的修改，光用 “回撤” 是找不回来的。而 “版本管理工具” 能记录每次的修改，只要提交到版本仓库，你就可以找到之前任何时刻的状态（文本状态）。&lt;/p&gt;&lt;p&gt;下面的内容就是列举了常用的 Git 命令和一些小技巧，可以通过 “页面内查找” 的方式进行快速查询：&lt;code&gt;Ctrl/Command+f&lt;/code&gt;。&lt;/p&gt;&lt;h2 id=&quot;开卷必读&quot;&gt;&lt;a href=&quot;#开卷必读&quot; class=&quot;headerlink&quot; title=&quot;开卷必读&quot;&gt;&lt;/a&gt;开卷必读&lt;/h2&gt;&lt;p&gt;&lt;em&gt;如果之前未使用过 Git，可以学习 &lt;a href=&quot;http://rogerdudler.github.io/git-guide/index.zh.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Git 小白教程&lt;/a&gt;入门&lt;/em&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;strong&gt;一定要先测试命令的效果后&lt;/strong&gt;，再用于工作环境中，以防造成不能弥补的后果！&lt;strong&gt;到时候别拿着砍刀来找我&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;所有的命令都在&lt;code&gt;git version 2.7.4 (Apple Git-66)&lt;/code&gt;下测试通过&lt;/li&gt;&lt;li&gt;统一概念：&lt;ul&gt;&lt;li&gt;工作区：改动（增删文件和内容）&lt;/li&gt;&lt;li&gt;暂存区：输入命令：&lt;code&gt;git add 改动的文件名&lt;/code&gt;，此次改动就放到了 ‘暂存区’&lt;/li&gt;&lt;li&gt;本地仓库(简称：本地)：输入命令：&lt;code&gt;git commit 此次修改的描述&lt;/code&gt;，此次改动就放到了 ’本地仓库’，每个 commit，我叫它为一个 ‘版本’。&lt;/li&gt;&lt;li&gt;远程仓库(简称：远程)：输入命令：&lt;code&gt;git push 远程仓库&lt;/code&gt;，此次改动就放到了 ‘远程仓库’（GitHub 等)&lt;/li&gt;&lt;li&gt;commit-id：输出命令：&lt;code&gt;git log&lt;/code&gt;，最上面那行 &lt;code&gt;commit xxxxxx&lt;/code&gt;，后面的字符串就是 commit-id
    
    </summary>
    
    
      <category term="技术栈" scheme="https://ghostsf.com/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="git" scheme="https://ghostsf.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>四种软件架构：Serverless架构、微服务架构、分布式架构、单体架构</title>
    <link href="https://ghostsf.com/architectures/"/>
    <id>https://ghostsf.com/architectures/</id>
    <published>2019-04-03T09:44:55.000Z</published>
    <updated>2020-03-03T05:37:42.520Z</updated>
    
    <content type="html"><![CDATA[<p>如果一个软件开发人员，不了解软件架构的演进，会制约技术的选型和开发人员的生存、晋升空间。这里我列举了目前主要的四种软件架构以及他们的优缺点，希望能够帮助软件开发人员拓展知识面。</p><a id="more"></a><p>一、单体架构</p><p>单体架构比较初级，典型的三级架构，前端(Web/手机端)+中间业务逻辑层+数据库层。这是一种典型的Java Spring mvc或者Python Django框架的应用。其架构图如下所示：</p><p><img src="../images/post/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84.jpg" alt="单体架构"></p><p>单体架构的应用比较容易部署、测试， 在项目的初期，单体应用可以很好地运行。然而，随着需求的不断增加， 越来越多的人加入开发团队，代码库也在飞速地膨胀。慢慢地，单体应用变得越来越臃肿，可维护性、灵活性逐渐降低，维护成本越来越高。下面是单体架构应用的一些缺点：</p><p>复杂性高： 以一个百万行级别的单体应用为例，整个项目包含的模块非常多、模块的边界模糊、 依赖关系不清晰、 代码质量参差不齐、 混乱地堆砌在一起。可想而知整个项目非常复杂。 每次修改代码都心惊胆战， 甚至添加一个简单的功能， 或者修改一个Bug都会带来隐含的缺陷。</p><p>技术债务： 随着时间推移、需求变更和人员更迭，会逐渐形成应用程序的技术债务， 并且越积 越多。“ 不坏不修”， 这在软件开发中非常常见， 在单体应用中这种思想更甚。 已使用的系统设计或代码难以被修改，因为应用程序中的其他模块可能会以意料之外的方式使用它。</p><p>部署频率低： 随着代码的增多，构建和部署的时间也会增加。而在单体应用中， 每次功能的变更或缺陷的修复都会导致需要重新部署整个应用。全量部署的方式耗时长、 影响范围大、 风险高， 这使得单体应用项目上线部署的频率较低。 而部署频率低又导致两次发布之间会有大量的功能变更和缺陷修复，出错率比较高。</p><p>可靠性差： 某个应用Bug，例如死循环、内存溢出等， 可能会导致整个应用的崩溃。</p><p>扩展能力受限： 单体应用只能作为一个整体进行扩展，无法根据业务模块的需要进行伸缩。例如，应用中有的模块是计算密集型的，它需要强劲的CPU； 有的模块则是IO密集型的，需要更大的内存。 由于这些模块部署在一起，不得不在硬件的选择上做出妥协。</p><p>阻碍技术创新： 单体应用往往使用统一的技术平台或方案解决所有的问题， 团队中的每个成员 都必须使用相同的开发语言和框架，要想引入新框架或新技术平台会非常困难。</p><p>二、分布式应用</p><p>中级架构，分布式应用，中间层分布式+数据库分布式，是单体架构的并发扩展，将一个大的系统划分为多个业务模块，业务模块分别部署在不同的服务器上，各个业务模块之间通过接口进行数据交互。数据库也大量采用分布式数据库，如redis、ES、solor等。通过LVS/Nginx代理应用，将用户请求均衡的负载到不同的服务器上。其架构图如下所示：</p><p><img src="../images/post/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84.jpg" alt="分布式架构"></p><p>该架构相对于单体架构来说，这种架构提供了负载均衡的能力，大大提高了系统负载能力，解决了网站高并发的需求。另外还有以下特点：</p><p>降低了耦合度：把模块拆分,使用接口通信,降低模块之间的耦合度。</p><p>责任清晰：把项目拆分成若干个子项目,不同的团队负责不同的子项目。</p><p>扩展方便：增加功能时只需要再增加一个子项目,调用其他系统的接口就可以。</p><p>部署方便:可以灵活的进行分布式部署。</p><p>提高代码的复用性：比如service层,如果不采用分布式rest服务方式架构就会在手机wap商城,微信商城,pc,android，ios每个端都要写一个service层逻辑,开发量大,难以维护一起升级,这时候就可以采用分布式rest服务方式,公用一个service层。</p><p>缺点 : 系统之间的交互要使用远程通信,接口开发增大工作量,但是利大于弊。</p><p>三、微服务架构</p><p>微服务架构，主要是中间层分解，将系统拆分成很多小应用（微服务），微服务可以部署在不同的服务器上，也可以部署在相同的服务器不同的容器上。当应用的故障不会影响到其他应用，单应用的负载也不会影响到其他应用，其代表框架有Spring cloud、Dubbo等。 其架构图如下所示：</p><p><img src="../images/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84.jpg" alt="微服务架构"></p><p>易于开发和维护： 一个微服务只会关注一个特定的业务功能，所以它业务清晰、代码量较少。 开发和维护单个微服务相对简单。而整个应用是由若干个微服务构建而成的，所以整个应用也会被维持在一个可控状态。</p><p>单个微服务启动较快： 单个微服务代码量较少， 所以启动会比较快。</p><p>局部修改容易部署： 单体应用只要有修改，就得重新部署整个应用，微服务解决了这样的问题。 一般来说，对某个微服务进行修改，只需要重新部署这个服务即可。</p><p>技术栈不受限：在微服务架构中，可以结合项目业务及团队的特点，合理地选择技术栈。例如某些服务可使用关系型数据库MySQL；某些微服务有图形计算的需求，可以使用Neo4j；甚至可根据需要，部分微服务使用Java开发，部分微服务使用Node.js开发。</p><p>微服务虽然有很多吸引人的地方，但它并不是免费的午餐，使用它是有代价的。使用微服务架构面临的挑战。</p><p>运维要求较高：更多的服务意味着更多的运维投入。在单体架构中，只需要保证一个应用的正常运行。而在微服务中，需要保证几十甚至几百个服务服务的正常运行与协作，这给运维带来了很大的挑战。</p><p>分布式固有的复杂性：使用微服务构建的是分布式系统。对于一个分布式系统，系统容错、网络延迟、分布式事务等都会带来巨大的挑战。</p><p>接口调整成本高：微服务之间通过接口进行通信。如果修改某一个微服务的API，可能所有使用了该接口的微服务都需要做调整。</p><p>重复劳动：很多服务可能都会使用到相同的功能，而这个功能并没有达到分解为一个微服务的程度，这个时候，可能各个服务都会开发这一功能，从而导致代码重复。尽管可以使用共享库来解决这个问题（例如可以将这个功能封装成公共组件，需要该功能的微服务引用该组件），但共享库在多语言环境下就不一定行得通了。</p><p>四、Serverless架构</p><p>当我们还在容器的浪潮中前行时，已经有一些革命先驱悄然布局另外一个云计算战场：Serverless架构。</p><p><img src="../images/post/Serverless%E6%9E%B6%E6%9E%84.jpg" alt="Serverless架构"></p><p>2014年11月14日，亚马逊AWS发布了新产品Lambda。当时Lambda被描述为：一种计算服务，根据时间运行用户的代码，无需关心底层的计算资源。从某种意义上来说，Lambda姗姗来迟，它像云计算的PaaS理念：客户只管业务，无需担心存储和计算资源。在此前不久，2014年10月22日，谷歌收购了实时后端数据库创业公司Firebase。Firebase声称开发者只需引用一个API库文件就可以使用标准REST API的各种接口对数据进行读写操作，只需编写HTML＋CSS＋JavaScrip前端代码，不需要服务器端代码（如需整合，也极其简单）。</p><p>相对于上两者，Facebook 在2014年二月收购的 Parse，则侧重于提供一个通用的后台服务。这些服务被称为Serverless或no sever。想到PaaS（平台即服务）了是吗？很像，用户不需要关心基础设施，只需要关心业务，这是迟到的PaaS，也是更实用的PaaS。这很有可能将会变革整个开发过程和传统的应用生命周期，一旦开发者们习惯了这种全自动的云上资源的创建和分配，或许就再也回不到那些需要微应用配置资源的时代里去了。</p><p>Serverless架构能够让开发者在构建应用的过程中无需关注计算资源的获取和运维，由平台来按需分配计算资源并保证应用执行的SLA（服务等级协议），按照调用次数进行计费，有效的节省应用成本。ServerLess的架构如上图所示。其优点如下所示：</p><p>低运营成本：在业务突发性极高的场景下，系统为了应对业务高峰，必须构建能够应对峰值需求的系统，这个系统在大部分时间是空闲的，这就导致了严重的资源浪费和成本上升。在微服务架构中，服务需要一直运行，实际上在高负载情况下每个服务都不止一个实例，这样才能完成高可用性；在Serverless架构下，服务将根据用户的调用次数进行计费，按照云计算pay-as-you-go原则，如果没有东西运行，你就不必付款，节省了使用成本。同时，用户能够通过共享网络、硬盘、CPU等计算资源，在业务高峰期通过弹性扩容方式有效的应对业务峰值，在业务波谷期将资源分享给其他用户，有效的节约了成本。</p><p>简化设备运维：在原有的IT体系中，开发团队即需要维护应用程序，同时还要维护硬件基础设施；Serverless架构中，开发人员面对的将是第三方开发或自定义的API 和URL，底层硬件对于开发人员透明化了，技术团队无需再关注运维工作，能够更加专注于应用系统开发。</p><p>提升可维护性：Serverless架构中，应用程序将调用多种第三方功能服务，组成最终的应用逻辑。目前，例如登陆鉴权服务，云数据库服务等第三方服务在安全性、可用性、性能方面都进行了大量优化，开发团队直接集成第三方的服务，能够有效的降低开发成本，同时使得应用的运维过程变得更加清晰，有效的提升了应用的可维护性。</p><p>更快的开发速度：这一点在现在互联网创业公司得到很好的体现，创业公司往往开始由于人员和资金等问题，不可能每个产品线都同时进行，这时候就可以考虑第三方的Baas平台，比如使用微信的用户认证、阿里云提供的RDS，极光的消息推送，第三方支付及地理位置等等，能够很快进行产品开发的速度，把工作重点放在业务实现上，把产品更快的推向市场。</p><p>但ServerLess架构也有其缺点：</p><p>厂商平台绑定：平台会提供Serverless架构给大玩家，比如AWS Lambda，运行它需要使用AWS指定的服务，比如API网关，DynamoDB，S3等等，一旦你在这些服务上开发一个复杂系统，你会粘牢AWS，以后只好任由他们涨价定价或者下架等操作，个性化需求很难满足，不能进行随意的迁移或者迁移的成本比较大，同时不可避免带来一些损失。Baas行业内一个比较典型的事件，2016年1月19日Facebook关闭曾经花巨额资金收购的Parse，造成用户不得不迁移在这个平台中产生一年多的数据，无疑需要花费比较大的人力和时间成本。</p><p>成功案例比较少，没有行业标准：目前的情况也只适合简单的应用开发，缺乏大型成功案例的推动。对于Serverless缺乏统一的认知以及相应的标准，无法适应所有的云平台。</p><p>目前微服务架构在四种架构中处于主流地位，很多应用第一、第二种架构的企业也开始慢慢转向微服务架构。到目前为止微服务的技术相对于二三年前已经比较成熟，第四种架构将是未来发展的一种趋势。如果你喜欢我的文章，欢迎关注我的简书，后续我将教会大家利用spring cloud和docker轻松愉快的构建微服务。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果一个软件开发人员，不了解软件架构的演进，会制约技术的选型和开发人员的生存、晋升空间。这里我列举了目前主要的四种软件架构以及他们的优缺点，希望能够帮助软件开发人员拓展知识面。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术栈" scheme="https://ghostsf.com/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="架构" scheme="https://ghostsf.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>记一次mbpr无端GG</title>
    <link href="https://ghostsf.com/mac-fall/"/>
    <id>https://ghostsf.com/mac-fall/</id>
    <published>2019-02-16T17:03:42.000Z</published>
    <updated>2020-03-03T05:37:42.524Z</updated>
    
    <content type="html"><![CDATA[<p>Emmm,今天我的mbpr在重启之后，发现所有app启动都卡死了，都未响应。</p><p>一脸懵逼的我，感觉这应该是系统出了问题。<br>回想之前，使用shimo连vpn，可以正常连通，但是代理过去的ip以及dns服务器都ping不通。<br>起初以为是家里软路由设置的ip网段和vpn代理过去的网段在同一个网段的问题（按道理没这个问题- -），后来换了个其他电脑验证了，果然跟这个没什么关系。<br>然后就在各种找mac上已装过的代理软件的问题，macProxy、ssr、surge还有shimo，研究了一圈，没发什么异常情况。<br>无奈就暂且搁置待议了。</p><p>然而，今天把mac重启了，出现了这一档奇怪的现象。各种强制关机重启之后，偶尔又好了。想想，就先将就用用吧。<br>但是不甘的我，还是纠结起来了。想想既然是系统性的问题，那就更新个mac系统版本再说吧，一看果然有最新系统版本了。<br>于是就准备随便地开始更新了，Mojave 10.14.3 走你。</p><a id="more"></a><p>mac自然地进入了进度条更新的状态，然后蛋疼的情况出现了。一直卡在了最后，还有一点点就是前进不了。卡住了。- -、<br>等了大半天（5个多小时，一般肯定在2小时内能搞定），很无奈，可以断定系统肯定是有问题了。另外，更新mac系统最好是在有线的情况下，无线网下更新系统基本有点作死了。</p><p>无奈，卡死了。强制重启，emmm，彻底进不去了。登录界面可以出来，但是输入账号密码之后，就卡住了，这次卡住，直接是app和finder都渲染不出来了。<br>就只有一个桌面背景，空空如也。一脸懵。</p><p>接下来就是学习一下如何自救了。首先是先看官网了。</p><p>emmm，最终搜索答案，只能如此。</p><p><a href="https://support.apple.com/zh-cn/HT204904" target="_blank" rel="noopener">https://support.apple.com/zh-cn/HT204904</a></p><p>一波操作后，重新安装最新版本系统。漫长等待之后…</p><p>再进去，还是GG。</p><p>无奈。</p><p>刚好下午有空，去天才吧看看。</p><p>然而，漫长等待之后。还是这番操作，然后各种建议格盘重新安装系统。- - 忧伤。<br>还有就是，更新系统最好不要自己更新，不要在wifi环境下更新 - -</p><p>好吧… 你说得都对</p><p>后来，我还是不太想格盘重新安装。要求全面检测了下硬件有没有问题，检测结果发现没有任何问题。<br>那么我就放心了。</p><p>一番捣腾。发现，在进入登录界面之后，等待10分钟左右，再输入密码，进入系统，就不会有什么问题。很是奇怪，可能还是系统有问题吧。<br>无奈，等有时间把资料整理整理，备份备份再说吧。<br>再去重新格盘，重新安装系统吧~</p><p>END</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Emmm,今天我的mbpr在重启之后，发现所有app启动都卡死了，都未响应。&lt;/p&gt;&lt;p&gt;一脸懵逼的我，感觉这应该是系统出了问题。&lt;br&gt;回想之前，使用shimo连vpn，可以正常连通，但是代理过去的ip以及dns服务器都ping不通。&lt;br&gt;起初以为是家里软路由设置的ip网段和vpn代理过去的网段在同一个网段的问题（按道理没这个问题- -），后来换了个其他电脑验证了，果然跟这个没什么关系。&lt;br&gt;然后就在各种找mac上已装过的代理软件的问题，macProxy、ssr、surge还有shimo，研究了一圈，没发什么异常情况。&lt;br&gt;无奈就暂且搁置待议了。&lt;/p&gt;&lt;p&gt;然而，今天把mac重启了，出现了这一档奇怪的现象。各种强制关机重启之后，偶尔又好了。想想，就先将就用用吧。&lt;br&gt;但是不甘的我，还是纠结起来了。想想既然是系统性的问题，那就更新个mac系统版本再说吧，一看果然有最新系统版本了。&lt;br&gt;于是就准备随便地开始更新了，Mojave 10.14.3 走你。&lt;/p&gt;
    
    </summary>
    
    
      <category term="事件簿" scheme="https://ghostsf.com/categories/%E4%BA%8B%E4%BB%B6%E7%B0%BF/"/>
    
    
      <category term="mac" scheme="https://ghostsf.com/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>Git</title>
    <link href="https://ghostsf.com/git/"/>
    <id>https://ghostsf.com/git/</id>
    <published>2018-05-25T02:40:26.000Z</published>
    <updated>2020-03-03T05:37:42.520Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git教程笔记"><a href="#Git教程笔记" class="headerlink" title="Git教程笔记"></a>Git教程笔记</h1><p>教程来自:<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">廖雪峰的官方网站</a></p><h2 id="Git简介"><a href="#Git简介" class="headerlink" title="Git简介"></a>Git简介</h2><h3 id="Git的诞生"><a href="#Git的诞生" class="headerlink" title="Git的诞生"></a>Git的诞生</h3><p>Linux的创始人Linus在2005年花两周时间用C语言写成，迅速成为最流行的分布式版本控制系统。</p><p>2008年Github网站上线，它为开源项目免费提供Git存储。</p><h3 id="集中式VS分布式"><a href="#集中式VS分布式" class="headerlink" title="集中式VS分布式"></a>集中式VS分布式</h3><p>CVS和SVN都是集中式版本控制系统，而Git是分布式版本控制系统。</p><p><strong>集中式版本控制系统</strong>的版本库集中放在中央服务器，每次需从中央服务器取回最新版本，再开始干活，干完活再把自己的活推送给中央服务器。最大的<strong>缺点</strong>就是必须联网工作。</p><p><strong>分布式版本控制系统</strong>没有中央服务器，每个人的电脑上都有一个完整的版本库。通常分布式版本控制系统也有一台充当“中央服务器”的电脑，但仅作用于方便“交换”大家的修改。<strong>优势</strong>是不必联网，还有强大的分支管理。</p><h3 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h3><p>略</p><h3 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h3><ul><li>第一步，找到合适的地方，创建一个空目录</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir learngit</span><br><span class="line">$ cd learngit</span><br></pre></td></tr></table></figure><ul><li>第二步，通过<code>git init</code>把这个目录变成git可以管理的仓库:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$git init</span><br></pre></td></tr></table></figure><p>可以通过<code>ls -ah</code>命令可以看到隐藏的<code>.git</code>目录。</p><a id="more"></a><h3 id="添加文件到Git仓库"><a href="#添加文件到Git仓库" class="headerlink" title="添加文件到Git仓库"></a>添加文件到Git仓库</h3><ul><li>第一步，使用命令<code>git add &lt;file&gt;</code>，可反复多次使用，添加多个文件。</li><li>第二步，使用命令<code>git commit</code>，加上需要备注的内容，完成。</li></ul><h2 id="时光机穿梭"><a href="#时光机穿梭" class="headerlink" title="时光机穿梭"></a>时光机穿梭</h2><ul><li>使用<code>git status</code>掌握仓库当前状态，如待提交等</li><li>使用<code>git diff</code>查看对文件进行了什么修改，difference。</li></ul><h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><p><img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/001384907584977fc9d4b96c99f4b5f8e448fbd8589d0b2000/0" alt=""></p><ul><li><p><code>HEAD</code>指向的版本就是当前的版本，版本穿梭使用命令<code>git reset --hard commit_id</code>，上个版本是<code>HEAD^</code>,上上个版本是<code>HEAD^^</code>,往上100个版本是<code>HEAD~100</code></p></li><li><p>穿梭前，用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本。如果嫌输出信息太多，可以加上<code>--pretty=online</code>参数。</p></li><li><p>要重返未来，用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本。</p><h3 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h3></li><li><p>工作区: 就是在电脑里能看到的目录</p></li><li><p>版本库: 工作区隐藏目录<code>.git</code>，是Git的版本库。</p></li></ul><p>Git的版本库中存了很多东西，最重要的有暂存区(stage)，还有git为我们自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的指针叫<code>HEAD</code><br><img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/001384907702917346729e9afbf4127b6dfbae9207af016000/0" alt=""></p><p>所以<code>git add</code>就是把要提交的多有修改放到暂存区(stage)，然后执行<code>git commit</code>就可以一次性把暂存区的所有修改提交到分支。</p><h3 id="管理修改"><a href="#管理修改" class="headerlink" title="管理修改"></a>管理修改</h3><p>第一次修改 -&gt; <code>git add</code> -&gt; 第二次修改 -&gt; <code>git commit</code></p><p>(第二次修改不会被提交)</p><p>第一次修改 -&gt; <code>git add</code> -&gt; 第二次修改 -&gt; <code>git add</code> -&gt; <code>git commit</code></p><p>(这样就能提交第二次修改了)</p><h3 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h3><ul><li>场景一：想直接丢掉工作区修改时，用<code>git checkout -- file</code>，撤销回和版本库一样的状态。</li><li>场景二：不但修改了文件，还添加到了暂存区时，想丢弃修改，分两步，第一步用<code>git reset HEAD &lt;file&gt;</code>，回到场景1，第二步再按场景一操作。</li><li>已经提交了不合适的修改到版本库时，想要撤销本次提交，参考之前版本回退一节，使用<code>git reset --hard commit_id</code>进行版本回退。前提是没有提交到远程库。</li></ul><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><ul><li>命令<code>git rm</code>用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。</li><li>不小心删错时，可以用<code>git checkout -- &lt;file&gt;</code>，轻松把误删文件恢复到最新版本。这个操作其实是用版本库里的版本替换工作区的版本，无论修改或删除都能一键还原。</li></ul><h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><p>除了可以自己搭建一台运行Git的服务器，还可以将代码先托管在GitHub(Git的远程仓库)上。</p><p>由于本地Git和GitHub仓库之间是通过SSH加密的，所以需要一点设置：</p><ul><li><p>第1步：创建SSH key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</span><br></pre></td></tr></table></figure><p>如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。</p></li><li><p>第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面，然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容：<br><img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/001384908342205cc1234dfe1b541ff88b90b44b30360da000/0" alt=""><br>点“Add Key”，你就应该看到已经添加的Key。</p></li></ul><p>当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。</p><h3 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h3><ul><li><p>首先登陆Github新建一个仓库”Create a new repo”</p></li><li><p>在本地仓库下运行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:michaelliao&#x2F;learngit.git</span><br></pre></td></tr></table></figure></li><li><p>把本地库的内容推送到远程，用<code>git push</code>命令，实际上是把当前的分支<code>master</code>推送到远程。(<code>git push -u origin master</code>，默认叫法<code>origin</code>，也可以改成别的)</p></li><li><p>由于远程库是空的，我们第一次推送到分支上时，加上了<code>-u</code>参数，Git不但会把本地的<code>master</code>分支内容推送到远程的<code>master</code>分支，还会把本地的<code>master</code>分支和远程的<code>master</code>分支关联起来，在以后的推送或者拉取时就可以简化命令</p></li><li><p>之后只要本地做了提交，就可以通过命令<code>git push origin master</code>把本地<code>master</code>分支的最新修改推送至Github</p></li></ul><p><strong>分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，有没有联网都可以正常工作，当有网络的时候，再把本地提交推送一下就完成了同步。而SVN在没有联网的时候是无法工作的。</strong></p><h3 id="从远程库克隆"><a href="#从远程库克隆" class="headerlink" title="从远程库克隆"></a>从远程库克隆</h3><p><em>如果从0开发，最好的方式是先创建远程库，然后从远程库克隆</em></p><ul><li><p>知道仓库地址后，使用<code>git clone</code>命令克隆</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:michaelliao&#x2F;gitskills.git</span><br></pre></td></tr></table></figure></li><li><p>Git支持多种协议，包括<code>https</code>，但通过<code>ssh</code>支持原生<code>git</code>协议速度最快</p></li></ul><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><p><em>可以创建属于自己的分支，等到开发完毕后再一次性合并到原来的分支上，这样既安全又不影响别人工作。</em></p><h3 id="创建与合并分支"><a href="#创建与合并分支" class="headerlink" title="创建与合并分支"></a>创建与合并分支</h3><ul><li><p><code>HEAD</code>严格来说不指向提交，而是指向<code>master</code>，而<code>master</code>才是指向提交的，所以，<code>HEAD</code>就是只想当前的分支。</p></li><li><p>每次提交<code>master</code>分支都会向前移动一步，这样随着不断提交，<code>master</code>分支的线也越来越长。</p></li><li><p>当创建新的分支(例如<code>dev</code>)时，Git新建了一个指针叫<code>dev</code>，指向<code>master</code>相同的提交，再把<code>HEAD</code>指向<code>dev</code>,就标识当前分支在<code>dev</code>上</p></li><li><p>再对工作区的修改和提交就是针对<code>dev</code>分支了，比如新提交一次后，<code>dev</code>指针往前移动一步，而<code>master</code>指针不变。<br><img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/0013849088235627813efe7649b4f008900e5365bb72323000/0" alt=""></p></li><li><p>加入在<code>dev</code>上的工作完成了，就可以把<code>dev</code>合并到<code>master</code>上。就是直接把<code>master</code>指向<code>dev</code>的当前提交，就完成了合并<br><img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/00138490883510324231a837e5d4aee844d3e4692ba50f5000/0" alt=""></p></li><li><p>所以合并分支就是相当于修改了指针，工作区内容不变。</p></li><li><p>合并完分之后，甚至可以删除<code>dev</code>分支。删除<code>dev</code>分支就是把<code>dev</code>指针给删掉，删掉后，我们就剩下了一条<code>matser</code>分支。</p></li></ul><p>实战:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;创建&#96;dev&#96;分支，然后切换到&#96;dev&#96;分支</span><br><span class="line">git checkout -b dev</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#96;git checkout&#96;命令加上&#96;-b&#96;参数表示创建并切换，相当于以下两条命令：</span><br><span class="line">git branch dev</span><br><span class="line">git checkout dev</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;然后用&#96;git branch&#96;命令查看当前分支，&#96;git branch&#96;就会列出所有分支，当前分支前面会标一个&#96;*&#96;号。</span><br><span class="line">git branch</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;我们就可以在&#96;dev&#96;分支上正常提交，比如对readme.txt做个修改</span><br><span class="line">git add readme.txt</span><br><span class="line">git commit -m &quot;branch test&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#96;dev&#96;分支的工作完成后，我们就可以切换回&#96;master&#96;分支，切换后不会显示刚才的修改。</span><br><span class="line">git checkout master</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;把dev分支的工作成果合并到&#96;master&#96;分支上</span><br><span class="line">git merge dev</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;合并完成后，就可以放心地删除&#96;dev&#96;分支了</span><br><span class="line">git branch -d dev</span><br></pre></td></tr></table></figure><p><strong>因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删除分支，这和直接在<code>master</code>分支上工作效果是一样的，但过程更安全</strong></p><p>###解决冲突</p><ul><li><p><code>master</code>分支和<code>feature1</code>分支都各自有了新的提交。这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突。<br><img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/001384909115478645b93e2b5ae4dc78da049a0d1704a41000/0" alt=""></p></li><li><p><code>git status</code>也可以告诉我们冲突的文件</p></li><li><p>手动修改之后再做保存，之后再提交就可以了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add readme.txt</span><br><span class="line">git commit -m &quot;conflict fixed&quot;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/00138490913052149c4b2cd9702422aa387ac024943921b000/0" alt=""></p></li><li><p>用带参数的<code>git log</code>可以看到分支的合并情况</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --graph --pretty&#x3D;&#x3D;online --abbrev-commit</span><br></pre></td></tr></table></figure><ul><li>最后删除<code>feature1</code>分支<code>git branch -d feature</code></li></ul><h3 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h3><p>合并分支时，加上<code>--no-ff</code>参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而<strong>fast forward</strong>合并就看不出来曾经做过合并。</p><h3 id="Bug分支"><a href="#Bug分支" class="headerlink" title="Bug分支"></a>Bug分支</h3><p><em>软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。</em></p><ul><li><p>修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；</p></li><li><p>当手头工作没有完成时，先把工作现场<code>git stash</code>一下，然后去修复bug，修复后，再git stash pop，回到工作现场。</p></li></ul><h3 id="Feature分支"><a href="#Feature分支" class="headerlink" title="Feature分支"></a>Feature分支</h3><p><em>添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。</em><br>如果要丢弃一个没有被合并过的分支，可以通过<code>git branch -D &lt;name&gt;</code>强行删除</p><h3 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h3><ul><li><p>查看远程库信息，使用git remote -v；</p></li><li><p>本地新建的分支如果不推送到远程，对其他人就是不可见的；</p></li><li><p>从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交；</p></li><li><p>在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致；</p></li><li><p>建立本地分支和远程分支的关联，使用git branch –set-upstream branch-name origin/branch-name；</p></li><li><p>从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。</p></li></ul><h3 id="Rebase"><a href="#Rebase" class="headerlink" title="Rebase"></a>Rebase</h3><ul><li><p>rebase操作可以把本地未push的分叉提交历史整理成直线；</p></li><li><p>rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。</p></li></ul><h2 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h2><p><strong>tag就是一个让人容易记住的有意义的名字，它和某个commit绑在一起</strong></p><h3 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h3><ul><li><p>命令<code>git tag &lt;tagname&gt;</code>用于新建一个标签，默认为HEAD，也可以指定一个commit id；</p></li><li><p>命令<code>git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;</code>可以指定标签信息；</p></li><li><p>命令<code>git tag</code>可以查看所有标签。</p></li></ul><h3 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a>操作标签</h3><ul><li><p>命令<code>git push origin &lt;tagname&gt;</code>可以推送一个本地标签；</p></li><li><p>命令<code>git push origin --tags</code>可以推送全部未推送过的本地标签；</p></li><li><p>命令<code>git tag -d &lt;tagname&gt;</code>可以删除一个本地标签；</p></li><li><p>命令<code>git push origin :refs/tags/&lt;tagname&gt;</code>可以删除一个远程标签。</p></li></ul><h2 id="使用Github"><a href="#使用Github" class="headerlink" title="使用Github"></a>使用Github</h2><ul><li><p>在GitHub上，可以任意Fork开源仓库；</p></li><li><p>自己拥有Fork后的仓库的读写权限；</p></li><li><p>可以推送pull request给官方仓库来贡献代码。</p></li></ul><h2 id="码云"><a href="#码云" class="headerlink" title="码云"></a>码云</h2><p>使用Github有时候会遇到访问速度慢的问题。<br>可以使用国内的Git托管服务 码云(gitee.com)<br>码云也提供免费的Git仓库。此外，还集成了代码质量检测、项目演示等功能。对于团队协作开发，码云还提供了项目管理、代码托管、文档管理的服务，5人以下小团队免费。</p><h2 id="自定义Git"><a href="#自定义Git" class="headerlink" title="自定义Git"></a>自定义Git</h2><ul><li><p>比如让git显示颜色：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global color.ui true</span><br></pre></td></tr></table></figure></li><li><p>忽略某些文件时，需要编写<code>.gitignore</code></p></li><li><p><code>.gitignore</code>文件本身要放到版本库里，并且可以对.gitignore做版本管理！</p></li><li><p>给Git配置好别名，就可以输入命令时偷个懒。我们鼓励偷懒。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;设置完就可以使用 git st 代替 git status啦</span><br><span class="line">git config --global alias.st status</span><br></pre></td></tr></table></figure></li><li><p>搭建Git服务器非常简单，通常10分钟即可完成；要方便管理公钥，用Gitosis；<br>要像SVN那样变态地控制权限，用Gitolite。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Git教程笔记&quot;&gt;&lt;a href=&quot;#Git教程笔记&quot; class=&quot;headerlink&quot; title=&quot;Git教程笔记&quot;&gt;&lt;/a&gt;Git教程笔记&lt;/h1&gt;&lt;p&gt;教程来自:&lt;a href=&quot;https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;廖雪峰的官方网站&lt;/a&gt;&lt;/p&gt;&lt;h2 id=&quot;Git简介&quot;&gt;&lt;a href=&quot;#Git简介&quot; class=&quot;headerlink&quot; title=&quot;Git简介&quot;&gt;&lt;/a&gt;Git简介&lt;/h2&gt;&lt;h3 id=&quot;Git的诞生&quot;&gt;&lt;a href=&quot;#Git的诞生&quot; class=&quot;headerlink&quot; title=&quot;Git的诞生&quot;&gt;&lt;/a&gt;Git的诞生&lt;/h3&gt;&lt;p&gt;Linux的创始人Linus在2005年花两周时间用C语言写成，迅速成为最流行的分布式版本控制系统。&lt;/p&gt;&lt;p&gt;2008年Github网站上线，它为开源项目免费提供Git存储。&lt;/p&gt;&lt;h3 id=&quot;集中式VS分布式&quot;&gt;&lt;a href=&quot;#集中式VS分布式&quot; class=&quot;headerlink&quot; title=&quot;集中式VS分布式&quot;&gt;&lt;/a&gt;集中式VS分布式&lt;/h3&gt;&lt;p&gt;CVS和SVN都是集中式版本控制系统，而Git是分布式版本控制系统。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;集中式版本控制系统&lt;/strong&gt;的版本库集中放在中央服务器，每次需从中央服务器取回最新版本，再开始干活，干完活再把自己的活推送给中央服务器。最大的&lt;strong&gt;缺点&lt;/strong&gt;就是必须联网工作。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;分布式版本控制系统&lt;/strong&gt;没有中央服务器，每个人的电脑上都有一个完整的版本库。通常分布式版本控制系统也有一台充当“中央服务器”的电脑，但仅作用于方便“交换”大家的修改。&lt;strong&gt;优势&lt;/strong&gt;是不必联网，还有强大的分支管理。&lt;/p&gt;&lt;h3 id=&quot;安装git&quot;&gt;&lt;a href=&quot;#安装git&quot; class=&quot;headerlink&quot; title=&quot;安装git&quot;&gt;&lt;/a&gt;安装git&lt;/h3&gt;&lt;p&gt;略&lt;/p&gt;&lt;h3 id=&quot;创建版本库&quot;&gt;&lt;a href=&quot;#创建版本库&quot; class=&quot;headerlink&quot; title=&quot;创建版本库&quot;&gt;&lt;/a&gt;创建版本库&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;第一步，找到合适的地方，创建一个空目录&lt;/li&gt;&lt;/ul&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ mkdir learngit&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ cd learngit&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;ul&gt;&lt;li&gt;第二步，通过&lt;code&gt;git init&lt;/code&gt;把这个目录变成git可以管理的仓库:&lt;/li&gt;&lt;/ul&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$git init&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;可以通过&lt;code&gt;ls -ah&lt;/code&gt;命令可以看到隐藏的&lt;code&gt;.git&lt;/code&gt;目录。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术栈" scheme="https://ghostsf.com/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
      <category term="git" scheme="https://ghostsf.com/tags/git/"/>
    
  </entry>
  
</feed>
